[
    {
      "Id": 2,
      "Url": "Service-Worker-Rendre-votre-site-accessible-meme-sans-connexion",
      "Title": "Service Worker : Rendre votre site accessible même sans connexion !",
      "Description": "Dans cet article nous allons voir comment utiliser les nouvelles API des services workers afin de rendre une application web disponible sans connexion internet. Il s'agit d'un des critères primordiaux afin de faire une Progressive Web App. ",
      "PublicationDate": "2017-12-02 15:58:36.047",
      "CategoryId": 1002,
      "Tags": null,
      "MarkDownContent": "Dans cet article nous allons voir comment utiliser les nouvelles API des\r\nservices workers afin de rendre une application web disponible sans\r\nconnexion internet. Il s'agit d'un des critères primordiaux afin de\r\nfaire une Progressive Web App. \r\n\r\nQu'est-ce qu'un service worker ?\r\n----------------------------------\r\n\r\nUn service worker est simplement un fichier javascript. Il est exécuté\r\nsous la forme d'une tâche qui vient s'insérer entre le navigateur et\r\nle serveur qui sert l'application. Celui-ci tourne comme un singleton\r\nau niveau du navigateur. Donc si deux onglets sont ouverts dans le\r\nnavigateur sur une application qui utilise un service worker, ces deux\r\nonglets se partageront la même instance de ce dernier.\r\n\r\nLes service workers peuvent intercepter les requêtes HTTP et retourner\r\neux mêmes une réponse. Il est donc possible de stocker le résultat de\r\nces requêtes et de retourner une version locale la prochaine fois que la\r\nmême ressource est demandée. C'est exactement de cette manière qu'il\r\nest possible de rendre une application disponible hors connexion.\r\n\r\nLe fonctionnement des services worker est événementiel. Il est par\r\nexemple possible de s'abonner à l'événement \"install\" qui est levé\r\nlorsque le service worker est installé ou encore à l'événement\r\n\"fetch\" levé lors qu'une requête HTTP est effectuée par un client. \r\n\r\nL'interface Cache \r\n-------------------\r\n\r\n Au sein des services workers il existe une interface de cache qui\r\npermet de stocker des paires d'objets Request/Reponse. Cette interface\r\nexpose différentes méthodes permettant d'ajouter, supprimer, mettre à\r\njour ou tester l'existence d'une requête dans le cache. Mais\r\nl'implémentation de la gestion de la mise à jour du cache ou de sa\r\ndurée de vie est à la charge du développeur.\r\n\r\nMise en place\r\n-------------\r\n\r\nAfin de rendre disponible une application web hors connexion il faut\r\ndonc commencer par enregistrer le service worker. Pour cela, il suffit\r\nd'appeler la méthode navigator.serviceWorker.register. Cette méthode\r\nprend en paramètre l'url à laquelle le fichier javascript du service\r\nworker est disponible et retourne une Promise. Le résultat de cette\r\npromise permet de traiter les cas d'erreur.\r\n\r\n``` javascript\r\nif ('serviceWorker' in navigator) {\r\n  navigator.serviceWorker.register('/sw.js').then(function(reg) {\r\n    // registration worked\r\n    console.log('Registration succeeded');\r\n  }).catch(function(error) {\r\n    // registration failed\r\n    console.log('Registration failed with ' + error);\r\n  });\r\n};\r\n```\r\n\r\nCôté service worker, afin de se greffer aux requêtes entrantes, il faut\r\ns'abonner à l'évenement \"fetch\". Sur cet événement, il est possible\r\nd'appeler la méthode respondWith. Celle-ci attend un objet de type\r\nResponse. C'est cet objet qui sera envoyé au navigateur en tant que\r\nreponse HTTP.  Le bout de code suivant permet de reproduire le\r\ncomportement traditionnel du navigateur. En effet, on effectue ici\r\nl'appel HTTP en utilisant la méthode fetch et on passe le résultat de\r\ncet appel à la méthode respondWith.\r\n\r\n``` javascript\r\nthis.addEventListener(\"fetch\", event => {\r\n    event.respondWith(\r\n      (async () => {\r\n        return await fetch(event.request);\r\n        })());\r\n  });\r\n```\r\n\r\nPour s'assurer que c'est maintenant bien le service worker qui\r\ns'occupe des requêtes de notre application, on peut vérifier dans le\r\ncolonne size de l'onglet Network des DevTools de Chrome que la mention\r\n\"from ServiceWorker\" apparait bien.\r\n\r\n![service-worker.png](https://infiniteblogs.blob.core.windows.net:443/medias/f45edef4-3d7e-4f79-8ccd-6e1b45e3d075_service-worker.png){width=\"904\"\r\nheight=\"200\"}\r\n\r\nAfin d'utiliser l'interface de cache pour rendre une application\r\ndisponible hors connexion il faut commencer par ouvrir un cache. Les\r\ncaches sont nommés et peuvent donc être versionnés ou catégorisés. Pour\r\nen ouvrir un, il suffit d'appeler la méthode open sur l'objet caches.\r\nCette méthode prend en paramètre le nom du cache et retourne une Promise\r\nde l'instance du cache : \r\n\r\n``` javascript\r\nlet cacheName = \"v1\";\r\nlet cache = await caches.open(cacheName);\r\n```\r\n\r\nSur cet objet , il va être prossible d'appeler la méthode add pour\r\najouter une requête dans le cache. Une fois ajoutée, il est possible de\r\nrécupérer la réponse associée en appelant la méthode match : \r\n\r\n``` javascript\r\nawait cache.add(event.request);\r\nlet response = await cache.match(event.request);\r\n```\r\n\r\nIl est également possible de mettre des objets en cache avant que le\r\nnavigateur en fasse la requête. Pour cela, il faut s'abonner à\r\nl'événement \"install\".  Cet événement est levé lorsque le service\r\nworker est installé par le navigateur. Il n'est donc levé qu'une fois\r\npar version du service worker, peu importe le nombre de visite de\r\nl'utilisateur :\r\n\r\n``` javascript\r\nthis.addEventListener('install', function(event) {\r\n    event.waitUntil((async () => {\r\n        let cache = await caches.open(cacheName);\r\n        await cache.addAll([\r\n            \"offline.html\",\r\n            \"logo.png\",\r\n            \"other-assets.png\",\r\n        ]);\r\n    })());\r\n});\r\n```\r\n\r\nVoici un exemple complet de stratégie de cache:  \r\n\r\n``` javascript\r\nlet cacheName = \"v1\";\r\n\r\nthis.addEventListener('install', function(event) {\r\n    event.waitUntil((async () => {\r\n        let cache = await caches.open(cacheName);\r\n        await cache.addAll([\r\n            \"offline.html\",\r\n            \"logo.png\",\r\n            \"other-assets.png\",\r\n        ]);\r\n    })());\r\n});\r\n\r\nthis.addEventListener(\"fetch\", event => {\r\n  event.respondWith(\r\n    (async () => {\r\n      let cache = await caches.open(cacheName);\r\n      try {\r\n        await cache.add(event.request);\r\n      } catch (e) {\r\n        //Echec de l'ajout dans le cache (hors connection)\r\n      }\r\n      let response = await cache.match(event.request);\r\n      //Si la réponse n'est pas dans le cache, fallback sur une page d'information\r\n      if (!response) {\r\n        response = await cache.match(\"offline.html\");\r\n      }\r\n      return response;\r\n    })()\r\n  );\r\n});\r\n```\r\n\r\nDans cet exemple, les requêtes sont systèmatiquement ajoutées dans le\r\ncache et récupérées depuis celui-ci. De plus un fallback est ajouté pour\r\ngérer le cas où l'utilisateur visite une page hors connexion qui n'est\r\npas encore dans son cache.\r\n\r\nCompatibilité\r\n-------------\r\n\r\nLes services workers ne sont disponibles que dans Chrome, Firefox et\r\nOpéra pour le moment. Concernant Safari et Edge, le support est\r\nactuellement en cours de développement. Internet Explorer est donc le\r\nseul à ne pas avoir prévu de supporter cette fonctionnalité. Coté\r\nmobile, seul Android supporte cette API.\r\n\r\nC'est à cause de cette compatibilité que l'on peut se permettre\r\nd'utiliser les fonctionnalités ECMAScript 6 comme les fonctions\r\nasynchrones. \r\n\r\n \r\n\r\nA vous de définir votre propre gestion du cache maintenant !\r\n"
    },
    {
      "Id": 3,
      "Url": "Rendu-cote-serveur-dAngular-Part-33-ASPNET-Core",
      "Title": "Rendu côté serveur d'Angular Part 3/3 ASP.NET Core",
      "Description": "Cet article est le dernier d'une série de 3 traitant du sujet du rendu serveur d'une application Angular. Dans cette partie, nous nous intéresserons à la mise en place avec un serveur ASP.NET Core",
      "PublicationDate": "2017-12-18 00:00:00.000",
      "CategoryId": 2,
      "Tags": "angular,ssr,asp.net core",
      "MarkDownContent": "Cet article est le dernier d'une série de 3 traitant du sujet du rendu\r\nserveur d'une application Angular. Dans cette partie, nous nous\r\nintéresserons à la mise en place avec un serveur ASP.NET Core. La partie\r\nprécédente concernait la mise en place avec server Node.JS\r\n([ici](../../posts/Angular/rendu-cote-serveur-d-angular-part-2-3-nodejs)) et\r\nla première partie concernant la théorie\r\n([ici](../../posts/Angular/rendu-cote-serveur-d-angular-part-1-3)). \r\n\r\nCet article s'appuie enormément sur les principes de la mise en place\r\navec Node.JS. En effet, le fonctionnement du rendu côté serveur avec\r\nASP.NET Core est basé sur l'éxécution de processus Node.\r\n\r\nConcernant l'organisation des répertoires pour cet article, un dossier\r\n\"angular\" contenant un projet angular a été créé à la racine d'un\r\nprojet ASP.NET Core vide. Ce choix est arbitraire et est laissé au\r\ndeveloppeur. Cependant, attention aux urls relatives dans les exemples\r\nsi vous ne suivez pas cette organisation.\r\n\r\n![arbre des répertoires](https://i.imgur.com/N9SwjkM.png)\r\n\r\nCôté Angular\r\n------------\r\n\r\nLa première étape est de créer un module spécifique pour le serveur.\r\nPour celà, on peut se référer à la partie \"Création du module serveur\"\r\nde l'article [Rendu côté serveur d'Angular Part 2/3\r\nNode.js](../../posts/web/rendu-cote-serveur-d-angular-part-2-3-nodejs \"Rendu côté serveur d'Angular Part 2/3 Node.js\").\r\n\r\nEnsuite il faut créer un fichier main (src/main.server.ts) pour le\r\nserveur. Ce fichier va simplement servir à exposer le module serveur de\r\nnotre application. \r\n\r\n``` javascript\r\nimport { enableProdMode } from '@angular/core';\r\nexport { AppServerModule } from './app/app-server.module';\r\n\r\nenableProdMode();\r\n```\r\n\r\nPour la compilation, nous allons créer une application angular/cli\r\nplutôt que d'écrire un fichier webpack. Pour cela, il faut commencer\r\npar créer un fichier tsconfig.json (src/tsconfig.server.json). Ce\r\nfichier va servir à préciser le module d'entrée et ajouter le fichier\r\nmain.server.ts à la compilation. Pour plus simplicité, on va étendre le\r\nfichier src/tsconfig.app.json \r\n\r\n``` json\r\n{\r\n  \"extends\": \"./tsconfig.app.json\",\r\n  \"compilerOptions\": {\r\n    \"outDir\": \"../out-tsc/server\",\r\n    \"module\": \"commonjs\"\r\n  },\r\n  \"files\": [\r\n    \"main.server.ts\"\r\n  ],\r\n  \"exclude\": [\r\n    \"test.ts\",\r\n    \"**/*.spec.ts\"\r\n  ],\r\n  \"angularCompilerOptions\": {\r\n    \"entryModule\": \"app/app.server.module#AppServerModule\"\r\n  }\r\n}\r\n```\r\n\r\nLes points importants de cet objet de configuration sont :\r\n\r\n-   \"module\" doit être set à commonjs (les autres n'étant pas\r\n    supportés pour le moment)\r\n-   \"files\" doit contenir le fichier \"main.server.ts\" créé\r\n    précédemment pour l'ajouter à la compilation\r\n-   \"angularCompilerOptions.entryModule\" doit pointer vers le module\r\n    serveur de notre application. La syntaxe de cette dernière propriété\r\n    est la suivante: *chemin/vers/le/fichier\\#NomDeLaClasse.*\r\n\r\nOn a maintenant tous les éléments en main pour créer une application\r\nangular/cli. Pour cela, il suffit d'ajouter un objet dans le tableau\r\napps du fichier .angular-cli.json\r\n\r\n``` json\r\n{\r\n      \"name\": \"server\",\r\n      \"index\": \"index.html\",\r\n      \"platform\": \"server\",\r\n      \"root\": \"src\",\r\n      \"outDir\": \"dist-server\",\r\n      \"main\": \"main.server.ts\",\r\n      \"tsconfig\": \"tsconfig.server.json\",\r\n      \"environmentSource\": \"environments/environment.ts\",\r\n      \"environments\": {\r\n        \"dev\": \"environments/environment.ts\",\r\n        \"prod\": \"environments/environment.prod.ts\"\r\n      }\r\n    }\r\n```\r\n\r\nLes points importants de cet objet de configuration sont :\r\n\r\n-   \"platform\" doit être set à \"server\"\r\n-   \"tsconfig\" doit pointer vers le fichier tsconfig précédemment créé\r\n    (relativement au dossier src)\r\n-   \"main\" doit pointer vers le fichier main.server.ts  précédemment\r\n    créé (relativement au dossier src)\r\n\r\nDans ce fichier de configuration, il faut également modifier la\r\npropriété outDir de l'application principale pour pointer vers le\r\ndossier wwwroot du projet ASP.NET Core.\r\n\r\n``` json\r\n{\r\n      \"root\": \"src\",\r\n      \"outDir\": \"../wwwroot\",\r\n      \"assets\": [\r\n        \"assets\",\r\n        \"favicon.ico\"\r\n      ],\r\n      \"index\": \"index.html\",\r\n      \"main\": \"main.ts\",\r\n      \"polyfills\": \"polyfills.ts\",\r\n      \"test\": \"test.ts\",\r\n      \"tsconfig\": \"tsconfig.app.json\",\r\n      \"testTsconfig\": \"tsconfig.spec.json\",\r\n      \"prefix\": \"app\",\r\n      \"styles\": [\r\n        \"styles.css\"\r\n      ],\r\n      \"scripts\": [],\r\n      \"environmentSource\": \"environments/environment.ts\",\r\n      \"environments\": {\r\n        \"dev\": \"environments/environment.ts\",\r\n        \"prod\": \"environments/environment.prod.ts\"\r\n      }\r\n    }\r\n```\r\n\r\nOn peut maintenant modifier le script npm de build afin qu'il effectue\r\nla compilation des applications angular déclarées :\r\n\r\n``` json\r\n{\r\n   ...\r\n  \"scripts\": {\r\n     ...\r\n    \"build\": \"ng build --prod && ng build --prod --app server --output-hashing=none\",\r\n     ... \r\n },\r\n   ...\r\n}\r\n```\r\n\r\nOn ajoute le flag \\--output-hashing=none afin qu'Angular ne génére pas\r\nun nom de fichier contenant un guid pour la partie serveur. On a en\r\neffet besoin de référencer ce fichier, il lui faut donc un nom statique.\r\n\r\nL'exécution de la commande npm run build remplit maintenant le dossier\r\nwwwroot du projet ASP.NET Core avec l'application cliente Angular et\r\ncrée un dossier dist-server contenant un fichier main.bundle.js.\r\n\r\nOn va maintenant créer le script Node.JS que va exécuter le serveur\r\nASP.NET Core. Pour cela, il faut comprendre que ce serveur attend un\r\nmodule commonjs avec un export global. Cet export doit exposer une\r\nfonction prenant en paramètre un callback. C'est le resultat de ce\r\ncallback qui sera reçu par le serveur. \r\n\r\n``` javascript\r\nmodule.exports = function (callback) {\r\n  callback(null /* les erreurs vont ici */, \"hello world\");\r\n}\r\n```\r\n\r\nLe serveur recevra la valeur \"hello world\" s'il exécute l'exemple\r\nci-dessus. Il est également possible de passer des paramètres\r\nsupplémentaires depuis le serveur. Ces paramètres seront passés à la\r\nfonction exportée.\r\n\r\nPour effectuer le rendu de l'application angular, on va se servir du\r\nrenderModuleFactory en utilisant le module exporté dans le fichier\r\nmain.server.ts (main.bundle.js pour la version compilé). Pour en savoir\r\nplus sur le fonction du renderModuleFactory, rendez-vous sur\r\nl'article [Rendu côté serveur d'Angular Part 2/3\r\nNode.js](../../posts/web/rendu-cote-serveur-d-angular-part-2-3-nodejs \"Rendu côté serveur d'Angular Part 2/3 Node.js\") partie\r\n\"Création du serveur Node.JS\". On va également considérer que le\r\nserveur nous envoie l'url demandée en second paramètre.\r\n\r\n``` javascript\r\nconst renderModuleFactory = require('@angular/platform-server').renderModuleFactory;\r\nconst AppServerModuleNgFactory = require('./dist-server/main.bundle').AppServerModuleNgFactory;\r\nconst readFileSync = require('fs').readFileSync;\r\nrequire('zone.js');\r\n\r\nconst file = readFileSync('./wwwroot/index.html').toString();\r\n\r\nmodule.exports = function (callback, path) {\r\n  renderModuleFactory(AppServerModuleNgFactory, {\r\n    document: file,\r\n    url: path\r\n  }).then(body => {\r\n    callback(null, body);\r\n  });\r\n}\r\n```\r\n\r\nPour cet exemple, ce script (server.js) est placé à la racine du projet\r\nangular. On a maintenant terminé avec la partie Angular, voyons\r\nmaintenant comment configuer le projet ASP.NET Core\r\n\r\nCôté ASP.NET Core\r\n-----------------\r\n\r\nPour commencer, il faut ajouter les services Node dans le moteur\r\nd'injection de dépendances. Pour cela, il suffit d'appeler la méthode\r\nAddNodeServices dans la méthode ConfigureServices de la classe Startup: \r\n\r\n``` csharp\r\npublic void ConfigureServices(IServiceCollection services)\r\n {\r\n      services.AddMvc();\r\n      services.AddNodeServices();\r\n }\r\n```\r\n\r\nIl est maintenant possible d'injecter l'interface INodeServices. Cette\r\ninterface expose une méthode générique InvokeAsync qui permet\r\nd'exécuter un script Node.JS. Le premier paramètre de cette méthode est\r\nle chemin vers le script à exécuter, les suivants sont les paramètres\r\nqui seront passés au script Node.JS. Pour récupérer l'html pré-rendu de\r\nnotre application Angular dans une action de contrôleur, il suffit donc\r\nd'écrire le code suivant :\r\n\r\n``` csharp\r\npublic class HomeController : Controller\r\n    {\r\n        [HttpGet]\r\n        public async Task<IActionResult> Index([FromServices]INodeServices nodeServices)\r\n        {\r\n            ViewData[\"ResultFromNode\"] = await nodeServices.InvokeAsync<string>(\"./angular/server.js\", Request.Path);\r\n            return View();\r\n        }\r\n    }\r\n```\r\n\r\nOn passe ici Request.Path en tant que second paramètre afin que le\r\nscript Node.JS et notre application Angular puissent récupérer la route\r\ndemandée. Cet appel nous renvoie le html pré-rendu de notre application.\r\nCelui-ci est ajouté au ViewBag afin que l'on puisse effectuer le rendu\r\ndans une page Razor avec la syntaxe suivante :\r\n\r\n``` csharp\r\n@Html.Raw(ViewBag.ResultFromNode)\r\n```\r\n\r\nIl ne reste plus maintenant qu'à ajouter un fallback dans le routage de\r\nl'application ASP.NET Core afin que les urls non reconnues par celui-ci\r\nsoient envoyées vers le contrôleur de rendu de l'application Angular.\r\nPour cela on peut se servir de la méthode d'extension\r\nMapSpaFallbackRoute lors de la configuration des routes qui est\r\njustement prévue à cet effet: \r\n\r\n``` csharp\r\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env)\r\n  {\r\n      if (env.IsDevelopment())\r\n      {\r\n          app.UseDeveloperExceptionPage();\r\n      }\r\n\r\n      app.UseMvc(routes =>\r\n      {\r\n          routes.MapRoute(\r\n            name: \"default\",\r\n            template: \"{controller=Home}/{action=Index}/{id?}\");\r\n\r\n          routes.MapSpaFallbackRoute(\r\n            name: \"spa-fallback\",\r\n            defaults: new { controller = \"Home\", action = \"Index\" });\r\n\r\n      });\r\n      app.UseStaticFiles();\r\n  }\r\n```\r\n\r\nLa dernière étape est d'ajouter la compilation du projet angular en\r\ntarget de prébuild du projet ASP.NET Core. Pour cela, il suffit\r\nd'ajouter ce noeud au csproj:\r\n\r\n``` xml\r\n  <Target Name=\"PreBuild\" BeforeTargets=\"PreBuildEvent\">\r\n    <Exec Command=\"cd angular && npm run build\" />\r\n  </Target>\r\n```\r\n\r\nEt voilà, tout est maintenant en place. \r\n\r\nVous pouvez retrouver le code complet de cet exemple sur mon github à\r\nl'adresse suivante :\r\n<https://github.com/Willovent/angular-ssr-asp.net-core>\r\n\r\nBonus\r\n-----\r\n\r\nTout ce système et même plus (live reloading, partage de donnés\r\nclient/serveur etc\\...) est disponible sous la forme d'un template\r\ndotnet. Pour l'utiliser, il suffit de lancer la commande \r\n\r\n``` powershell\r\ndotnet new angular\r\n```\r\n\r\nHave fun !\r\n"
    },
    {
      "Id": 4,
      "Url": "Web-App-Manifest-Transformez-votre-site-web-en-application-mobile",
      "Title": "Web App Manifest: Transformez votre site web en application mobile !",
      "Description": "Le web manifest fait partie des guidelines pour la mise en place d'une Progressive Web App",
      "PublicationDate": "2017-12-06 00:00:00.000",
      "CategoryId": 1002,
      "Tags": null,
      "MarkDownContent": "Le web manifest fait partie des guidelines pour la mise en place d'une\r\nProgressive Web App. Pour en savoir plus sur les PWA, vous pouvez jeter\r\nun oeil par ici : [Progressive Web App ou comment se passer des stores\r\n?](../../posts/web/progressive-web-app-ou-comment-se-passer-des-stores \"Progressive Web App ou comment se passer des stores ?\")\r\n\r\nA quoi ça sert ?\r\n----------------\r\n\r\nLe web manifest va permettre de fournir des informations sur votre\r\napplication au navigateur. Celui-ci va alors pouvoir effectuer quelques\r\naméliorations de performance sur Desktop (par exemple charger une\r\ncouleur de fond avant même que le CSS ne soit téléchargé). Mais là où ce\r\nmanifest prend tout son sens, c'est sur mobile. En effet lorsqu'un\r\nmanifest est présent dans l'application, le navigateur va demander à\r\nl'utilisateur s'il veut ajouter l'application à son écran d'accueil.\r\nAinsi l'utilisateur pourra utiliser l'application en dehors du\r\ncontexte du navigateur, comme une \\\"vraie\\\" application mobile.\r\nL'avantage principal est donc que l'on peut investir le device de\r\nl'utilisateur sans passer par un store tout en gardant la flexibilité\r\ndu web (Deploiement et mise à jour instantanés, légèreté des paquets\r\netc\\...)\r\n\r\n![Add to\r\nhomescreen](https://developers.google.com/web/fundamentals/app-install-banners/images/add-to-home-screen.gif)\r\n\r\nComment ça marche\r\n-----------------\r\n\r\nLe web manifeste est en fait un simple fichier json. Il se présente sous\r\nla forme suivante : \r\n\r\n``` json\r\n{\r\n    \"name\": \"Exemple d'application\",\r\n    \"short_name\": \"Exemple d'app\",\r\n    \"background_color\": \"red\",\r\n    \"description\": \"Description de mon exemple d'application\",\r\n    \"orientation\": \"portrait-primary\",\r\n    \"scope\": \"/monapp/\",\r\n    \"start_url\": \"./\",\r\n    \"display\": \"standalone\",\r\n    \"theme_color\": \"yellow\",\r\n    \"icons\": [\r\n        {\r\n            \"src\": \"chemin/vers/image\",\r\n            \"sizes\": \"48x48\",\r\n            \"type\": \"image/png\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nVoici à quoi ces propriétés servent : \r\n\r\n-   **name** : Fournit le nom de\r\n    l'application (utilisé pour afficher l'application sur le device)\r\n-   **short\\_name** : Fournit un\r\n    nom court pour l'application (destiné à être affiché lorsque le nom\r\n    est trop long pour le contexte courant)\r\n-   **background\\_color** :\r\n    Fournit la couleur de fond de l'application. Cette valeur est\r\n    utilisée afin que le navigateur puisse afficher une couleur de fond\r\n    avant que la/les feuilles de style(s) soi(en)t chargée(s). Cela\r\n    permet une transition moins violente lors du chargement de\r\n    l'application\r\n-   **description** : Fournit une\r\n    description de ce que fait l'application.\r\n-   **orientation** : Définit\r\n    l'orientation par défaut de l'application (landscape, portrait\r\n    etc\\...)\r\n-   **scope** : Définit le scope\r\n    de l'application. Lorsque l'on sort de ce scope, le navigateur\r\n    reprend un affichage traditionnel. (url relative à l'url du\r\n    manifest). Dans l'exemple, si l'utilisateur navigue vers une url\r\n    ne commencant pas par /monapp/, (par exemple /monsite/mapage),\r\n    l'affichage traditionnel reprendra la main. Pour que toute\r\n    l'application web soit en dehors du contexte du navigateur, il\r\n    suffit de remplir cette propriété avec la valeur \\\"/\\\" ou encore ne\r\n    pas l'affecter du tout (\\\"/\\\" étant sa valeur par défaut).\r\n-   **start\\_url** : Définit\r\n    l'url chargée lorsque l'utilisateur lance l'application depuis la\r\n    page d'accueil (url relative à l'url du manifest)\r\n-   **display** : Définit la\r\n    façon dont doit s'afficher l'application. Lorsque cette valeur est\r\n    à standalone, l'application se lancera comme une application\r\n    native, sortie du contexte du navigateur.\r\n-   **theme\\_color** : Définit\r\n    une couleur servant de thème à l'application. Celle-ci est notament\r\n    utilisée comme couleur de contour lors de l'affichage multi-tâches\r\n    sur Android.\r\n-   **icons**:  Définit une liste\r\n    d'icons pour l'application. Il s'agit d'une liste afin de\r\n    pouvoir spéficier des icons pour multiple résolutions. Ils sont\r\n    utilisés lorsque l'application est ajoutée sur l'écran d'accueil\r\n    de l'utilisateur.\r\n\r\nAfin que le navigateur soit en mesure de trouver ce fichier, il faut lui\r\nspéficier son chemin dans l'HTML de l'application. Pour cela il suffit\r\nd'utiliser une balise link dans la partie head de l'application : \r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <link rel=\"manifest\" href=\"/manifest.json\">\r\n    <title>Document</title>\r\n</head>\r\n<body>\r\n    ...\r\n</body>\r\n</html>\r\n```\r\n\r\nGoogle met à disposition un outil permettant de générer ce manifest avec\r\nune interface très simple. Cet outil permet même de générer des icons à\r\ntous les formats. Il est accessible à cette adresse :\r\n<https://app-manifest.firebaseapp.com/>\r\n\r\n Génial, mais c'est compatible avec quoi ?\r\n-------------------------------------------\r\n\r\nMalheureusement, c'est le point faible de ces web app manifest. Ils ne\r\nsont compatibles qu'avec Android pour le moment. Les utilisateurs\r\nd'IPhone ne seront donc pas promptés afin d'ajouter l'application à\r\nleurs écran d'accueil.\r\n\r\n![Can i use: Web App\r\nManifest](https://i.imgur.com/yNJpOj7.png)\r\n\r\nCependant il ne faut pas hésiter à l'insérer tout de même dans vos\r\napplications. En effet, le temps de mise en place est très court et ne\r\nfournit pas d'expérience dégradée lorsque l'appareil n'est pas\r\ncompatible, seulement une expérience augmentée lorsque la feature est\r\nprésente.\r\n"
    },
    {
      "Id": 5,
      "Url": "Rendu-cote-serveur-dAngular-Part-23-Nodejs",
      "Title": "Rendu côté serveur d'Angular Part 2/3 Node.js",
      "Description": "Cet article est le deuxième d'une série de 3 traitant du sujet du rendu serveur d'une application Angular. Dans cette partie, nous nous intéresserons à la mise en place avec un serveur Node.JS",
      "PublicationDate": "2017-09-13 00:00:00.000",
      "CategoryId": 2,
      "Tags": null,
      "MarkDownContent": "Cet article est le deuxième d'une série de 3 traitant du sujet du rendu\r\nserveur d'une application Angular. Dans cette partie, nous nous\r\nintéresserons à la mise en place avec un serveur Node.JS. La partie\r\nprécédente concernait la théorie et est disponible\r\n[ici](../../posts/Angular/rendu-cote-serveur-d-angular-part-1-3). La partie\r\nsuivante traitera de la mise en place avec un serveur ASP.NET Core.\r\n\r\nComme vu dans l'article précédent, afin de mettre en place le rendu\r\ncoté serveur d'une application Angular, il faut commencer par créer un\r\nmodule spécifique pour le serveur. Ensuite il faut mettre en place le\r\nserveur en lui même et enfin effectuer la configuration de sa\r\ncompilation.\r\n\r\nPour cette mise en place on va considérer un projet classique généré\r\ndepuis la CLI Angular.\r\n\r\nCréation du module serveur\r\n--------------------------\r\n\r\nCe module nécessite la dépendance @angular/platform-server qui n'est\r\npas installée par défaut dans un projet créé avec la CLI Angular, il est\r\ndonc nécessaire de l'ajouter:\r\n\r\n``` powershell\r\nnpm install --save-dev @angular/platform-server\r\n```\r\n\r\n \r\n\r\nL'étape suivante est de créer un module qui importe le module principal\r\nde l'application ainsi que le module ServerModule. Le bootstrap de\r\nl'application doit être le même que dans le module principal de\r\nl'application. Le fichier associé est créé au même niveau que le\r\nfichier app.module.ts et est nommé app.server.module.ts. Son contenu est\r\nle suivant pour une application basée sur la CLI Angular : \r\n\r\n``` javascript\r\nimport { NgModule } from '@angular/core';\r\nimport { ServerModule } from '@angular/platform-server';\r\nimport { AppComponent } from './app.component';\r\nimport { AppModule } from './app.module';\r\n@NgModule({\r\n  imports: [\r\n          ServerModule,\r\n          AppModule\r\n  ],\r\n  bootstrap: [\r\n          AppComponent\r\n  ]\r\n})\r\nexport class AppServerModule {}\r\n```\r\n\r\n \r\n\r\nIl faut également modifier le module principal de l'application pour\r\nlui signaler qu'il devra s'attacher à un DOM existant lors de son\r\nbootstrapping (le DOM généré par le serveur). Pour cela il suffit\r\nd'appeler la méthode withServerTransition sur l'import au\r\nBrowserModule. Cette méthode prend en paramètre un objet avec une\r\npropriété appId. Cette propriété sera utilisée par le serveur ET le\r\nclient afin de se synchroniser une fois le client boostrappé.\r\n\r\n``` javascript\r\nimport …\r\n\r\n@NgModule({\r\n  declarations: […],\r\n  imports: [\r\n    BrowserModule.withServerTransition({appId : \"pomme-app\"}),\r\n    …\r\n  ],\r\n  providers: […],\r\n  bootstrap: [AppComponent]\r\n})\r\nexport class AppModule { }\r\n```\r\n\r\n \r\n\r\n L'application est maintenant prête à être exécutée par un serveur\r\nNode.JS, on peut donc passer à la suite.\r\n\r\nConfiguration de la Compilation AOT\r\n-----------------------------------\r\n\r\nLe serveur Node.JS aura besoin des fichiers générés lors de la\r\ncompilation AOT (Ahead Of Time). En effet celui-ci doit se servir d'une\r\nfactory de modules qui n'est générée que lors de cette compilation.\r\nPlus d'informations sur le sujet sont disponibles sur [la documentation\r\nofficielle](https://angular.io/guide/aot-compiler). Comme expliqué dans\r\ncette documentation, on va créer un fichier tsconfig pour générer les\r\nfichiers aot. Pour cela, le plus simple est de copier le fichier\r\n tsconfig.json à la racine du projet et de le nommer\r\ntsconfig.server.json. Dans ce fichier, ll faut ajouter un noeud\r\n\"files\" et le faire pointer sur le fichier app.server.module.ts : \r\n\r\n``` json\r\n  \"files\": [\r\n    \"src/app/app.server.module.ts\"\r\n  ]\r\n```\r\n\r\n \r\n\r\nIl faut également ajouter un noeud \"angularCompilerOptions\". Celui-ci\r\ndoit contenir une propriété \"genDir\" pointant vers la destination des\r\nfichiers AOT et une propriété \"entryModule\" pointant vers le module\r\nserveur. La syntaxe de cette dernière propriété est la suivante:\r\n*chemin/vers/le/fichier\\#NomDeLaClasse.* Dans notre cas ce noeud est\r\ndonc le suivant : \r\n\r\n``` json\r\n  \"angularCompilerOptions\": {\r\n    \"genDir\": \"src/aot\",\r\n    \"entryModule\": \"./src/app/app.server.module#AppServerModule\"\r\n  }\r\n```\r\n\r\n \r\n\r\nAvec ces deux entrées supplémentaires, le fichier tsconfig.server.json\r\ndoit donc ressembler à celà : \r\n\r\n``` json\r\n{\r\n  \"compileOnSave\": false,\r\n  \"compilerOptions\": {\r\n    \"outDir\": \"./dist/out-tsc\",\r\n    \"baseUrl\": \"src\",\r\n    \"sourceMap\": true,\r\n    \"declaration\": false,\r\n    \"moduleResolution\": \"node\",\r\n    \"emitDecoratorMetadata\": true,\r\n    \"experimentalDecorators\": true,\r\n    \"target\": \"es5\",\r\n    \"typeRoots\": [\r\n      \"node_modules/@types\"\r\n    ],\r\n    \"lib\": [\r\n      \"es2016\",\r\n      \"dom\"\r\n    ]\r\n  },\r\n  \"files\": [\r\n    \"src/app/app.server.module.ts\"\r\n  ],\r\n  \"angularCompilerOptions\": {\r\n    \"genDir\": \"src/aot\",\r\n    \"entryModule\": \"./src/app/app.server.module#AppServerModule\"\r\n  }\r\n}\r\n```\r\n\r\n \r\n\r\nA ce stade, il est possible de générer les fichiers de la compilation\r\nAOT en utilisant ngc, le compilateur angular utilisé par la CLI. Pour\r\ncela il suffit d'exécuter la commande suivante : \r\n\r\n``` powershell\r\n.\\node_modules\\.bin\\ngc -p .\\tsconfig.server.json\r\n```\r\n\r\n \r\n\r\nAinsi les fichiers sont créés, cela permettera d'avoir l'intellisense\r\nlors de la création du serveur. Les fichiers AOT seront générés en\r\nmémoire lors la compilation webpack, l'utilisation de ngc ici permet\r\nsimplement de valider la configuration du tsconfig.server.json et\r\napporter plus de confort au développement.\r\n\r\nCréation du serveur Node.JS\r\n---------------------------\r\n\r\n Il est maintenant temps de créer le serveur en lui-même. La première\r\nétape est d'ajouter ses dépendances. Pour le serveur en lui-même, seul\r\nexpress et ses definitions de type suffisent : \r\n\r\n``` powershell\r\nnpm install express @types/express --save-dev\r\n```\r\n\r\n \r\n\r\nAfin de compiler le serveur, il faudra webpack, son loader de fichiers\r\net les outils Angular spécifique à webpack : \r\n\r\n``` powershell\r\nnpm install webpack raw-loader @ngtools/webpack --save-dev\r\n```\r\n\r\n \r\n\r\nOn peut maintenant créer un fichier main.server.ts au même niveau que le\r\nfichier main.ts du projet. C'est ce fichier qui fera office de serveur\r\nNode.JS. Dans ce fichier, la première chose à faire est d'activer le\r\nmode de production d'Angular : \r\n\r\n``` javascript\r\nimport { enableProdMode } from '@angular/core';\r\nimport 'zone.js';\r\n\r\nenableProdMode();\r\n```\r\n\r\n \r\n\r\nOn importe également zone.js car ce paquet est nécessaire au\r\nfonctionnement d'Angular afin de lui fournir un contexte d'exécution\r\nasynchrone.\r\n\r\nEnsuite il faut récupérer la référence à express et créer une nouvelle\r\napplication. Express est le serveur web Node.JS dont nous allons nous\r\nservir.\r\n\r\n``` javascript\r\nimport * as express from 'express';\r\n\r\nconst app = express();\r\n```\r\n\r\n \r\n\r\nAfin que ce même serveur puisse également servir à retourner les\r\nfichiers nécessaires à l'exécution de l'application Angular, il faut\r\najouter un middleware de fichier statique :\r\n\r\n``` javascript\r\napp.use(express.static('.', { index: false }));\r\n```\r\n\r\nl'objet {index : false} permet de préciser que l'url racine \"/\" ne\r\ndoit pas retourner un fichier index.html, en effet on veut gérer nous\r\nmême cette route. \r\n\r\n \r\n\r\nEnfin on peut lancer le serveur express sur un port quelconque.\r\n\r\n``` javascript\r\napp.listen(8000, () => {\r\n  console.log('listening...');\r\n});\r\n```\r\n\r\n \r\n\r\nA ce stade, nous avons simplement créé un serveur de fichiers statiques.\r\nIl faut ensuite créer un moteur de modèles express. Ce genre de moteur\r\nprend une vue (html dans ce cas) et des paramètres en entrée et fournit\r\nune vue html interprétée en sortie.\r\n\r\nPour créer un moteur, il faut appeler la méthode engine sur\r\nl'application express. Cette méthode prend en paramètre le type des\r\nfichiers d'entrées (ici html) et une fonction devant effectuer la\r\ntransformation.\r\n\r\n``` javascript\r\napp.engine('html', ngEngine);\r\n```\r\n\r\n \r\n\r\nReste à définir le moteur en lui-même. Pour cela il suffit d'écrire une\r\nméthode prenant 3 paramètres. Le premier correspond au chemin vers le\r\nfichier html demandé. Le second paramètre est un objet qui est construit\r\nlors des appels au moteur de modèle. C'est à nous de remplir (ou non)\r\ncet objet. Le dernier paramètre est un callback qui prend lui-même deux\r\nparamètres. Il faut utiliser le premier paramètre du callback en cas\r\nd'erreur et le second en cas de succès contenant la chaine de caractère\r\nque le serveur doit retourner.\r\n\r\n``` javascript\r\nimport * as fs from 'fs';\r\n\r\nconst ngEngine = (filePath, options, callback) => {\r\n  const file = fs.readFileSync(filePath).toString();\r\n  callback(null, file);\r\n};\r\n```\r\n\r\n \r\n\r\nPour le moment ce moteur de vue ne fait que charger la page html\r\ndemandée avant de la retourner. Afin d'interpréter la page html avec\r\nnotre application Angular, il faut utiliser la méthode\r\nrenderModuleFactory située dans @angular/platform-server. Cette méthode\r\nprend deux paramètres. Le premier est la classe de factory associée au\r\nmodule serveur de l'application. Le second est un objet de type\r\nPlatformOption. Celui-ci contient une propriété document qu'il faut\r\nremplir en utilisant le contenu du fichier html sur lequel\r\nl'application doit bootstrapper et une propriété url qui doit contenir\r\nl'url appelée.\r\n\r\n``` javascript\r\nimport { renderModuleFactory } from '@angular/platform-server';\r\nimport { AppServerModuleNgFactory } from './aot/src/app/app.server.module.ngfactory';\r\nimport * as fs from 'fs';\r\n\r\nconst ngEngine = (filePath, options, callback) => {\r\n  const file = fs.readFileSync(filePath).toString();\r\n  renderModuleFactory(AppServerModuleNgFactory, {\r\n    document: file,\r\n    url: options.req.url\r\n  })\r\n};\r\n```\r\n\r\n \r\n\r\nLa méthode renderModuleFactory retourne une promise. Le résultat de\r\ncette promise contient la chaine de caractères de l'html rendu. Il ne\r\nreste donc plus qu'à appeler le callback dans le résultat de cette\r\npromise. Voici donc le code complet concernant le moteur de modèle :\r\n\r\n``` javascript\r\nconst ngEngine = (filePath, options, callback) => {\r\n  const file = fs.readFileSync(filePath).toString();\r\n  renderModuleFactory(AppServerModuleNgFactory, {\r\n    document: file,\r\n    url: options.req.url\r\n  })\r\n  .then(string => {\r\n    callback(null, string);\r\n  });\r\n};\r\n\r\napp.engine('html', ngEngine);\r\n```\r\n\r\n \r\n\r\nPour que ce moteur soit utilisé, il faut le préciser à express en\r\nutilisant le méthode set sur l'application avec en paramètre 'view\r\nengine'. Le deuxième paramètre de cette méthode doit être le type de\r\nfichier géré par le moteur (ici html)\r\n\r\nIl faut également lui spécifier le répertoire contenant les vues (ici\r\nc'est la racine du serveur) en utilisant cette même méthode avec le\r\nparamètre 'views'.\r\n\r\n``` javascript\r\napp.set('view engine', 'html');\r\napp.set('views', '.');\r\n```\r\n\r\n \r\n\r\nMaintenant que le moteur de modèles est en place, il faut l'appeler sur\r\ntoutes les urls qui peuvent être demandées au serveur. Il faut donc\r\nutiliser la méthode « get » de l'application express. Cette méthode\r\nprend deux paramètres en entrée. Le premier correspond à l'url, ou à un\r\npattern d'urls, à laquelle l'application doit répondre. Le second est\r\nla fonction qui effectue la création de la réponse HTTP. Cette fonction\r\nprend en paramètre la requête et la réponse HTTP. C'est sur cet objet\r\nresponse qu'un l'appel à la méthode render est effectué afin de faire\r\nappel au moteur de modèles.\r\n\r\n``` javascript\r\napp.get('*', (request, response) => {\r\n  response.render('index', { req: request });\r\n});\r\n```\r\n\r\n \r\n\r\nLe deuxième parmètre passé à la méthode render correpond à l'objet\r\noption qui est récupéré dans le moteur de modèles. On lui passe donc ici\r\nla requête afin que le moteur puisse en déduire l'url appelée\r\n\r\nLe fichier final doit donc ressembler à cela : \r\n\r\n``` javascript\r\nimport { renderModuleFactory } from '@angular/platform-server';\r\nimport { enableProdMode } from '@angular/core';\r\nimport 'zone.js';\r\nimport { AppServerModuleNgFactory } from './aot/src/app/app.server.module.ngfactory';\r\nimport * as express from 'express';\r\nimport * as fs from 'fs';\r\n\r\nenableProdMode();\r\n\r\nconst app = express();\r\n\r\nconst ngEngine = (filePath, options, callback) => {\r\n  const file = fs.readFileSync(filePath).toString();\r\n  renderModuleFactory(AppServerModuleNgFactory, {\r\n    document: file,\r\n    url: options.req.url\r\n  })\r\n  .then(string => {\r\n    callback(null, string);\r\n  });\r\n};\r\n\r\napp.engine('html', ngEngine);\r\n\r\napp.set('view engine', 'html');\r\napp.set('views', '.');\r\n\r\napp.use(express.static('.', { index: false }));\r\n\r\napp.get('*', (request, response) => {\r\n  response.render('index', { req: request });\r\n});\r\n\r\napp.listen(8000, () => {\r\n  console.log('listening...');\r\n});\r\n```\r\n\r\nLe serveur est maintenant terminé, reste à le compiler. Pour cela, nous\r\nallons nous servir de webpack. Il faut donc créer un fichier\r\nwebpack.server.config.ts. Voici le contenu de celui-ci: \r\n\r\n``` javascript\r\nconst ngtools = require('@ngtools/webpack');\r\nconst config = {\r\n    entry: {\r\n        main: './src/main.server.ts'\r\n    },\r\n    resolve: {\r\n        extensions: ['.ts', '.js']\r\n    },\r\n    target: 'node',\r\n    output: {\r\n        path: __dirname + '/dist',\r\n        filename: 'main.server.js'\r\n    },\r\n    plugins: [\r\n        new ngtools.AotPlugin({\r\n            tsConfigPath: './tsconfig.server.json',\r\n        })\r\n    ],\r\n    module: {\r\n        rules: [\r\n            { test: /\\.css$/, loader: 'raw-loader' },\r\n            { test: /\\.html$/, loader: 'raw-loader' },\r\n            { test: /\\.ts$/, loader: '@ngtools/webpack' }\r\n        ]\r\n    }\r\n}\r\nmodule.exports = config;\r\n```\r\n\r\nOn ne va pas rentrer dans le detail de ce fichier de configuration\r\nwebpack. Simplement, on utilise le loader @ngtools/webpack pour les\r\nfichiers .ts et on utilise le plugin AotPlugin se servant du fichier\r\ntsconfig créer précédement. Le reste est plutôt standard pour de la\r\ncompilation webpack. Utiliser @ngtools/webpack plutôt que le\r\ntraditionnel ts-loader permet de bundler les fichiers\r\nless/sass, d'optimiser les assets etc.. (Plus d'info sur la page\r\ngithub\r\n[@ngtools/webpack](https://github.com/angular/angular-cli/tree/master/packages/%40ngtools/webpack))\r\n\r\nIl faut encore exclure ce fichier de la compilation angular de la partie\r\ncliente. Pour cela, il suffit d'ajouter ce fichier dans la liste des\r\nexclusions du fichier tsconfig.app.json dans le dossier src : \r\n\r\n``` json\r\n{\r\n  \"extends\": \"../tsconfig.json\",\r\n  \"compilerOptions\": {\r\n    \"outDir\": \"../out-tsc/app\",\r\n    \"baseUrl\": \"./\",\r\n    \"module\": \"es2015\",\r\n    \"types\": []\r\n  },\r\n  \"exclude\": [\r\n    \"test.ts\",\r\n    \"**/*.spec.ts\",\r\n    \"main.server.ts\"\r\n  ]\r\n}\r\n```\r\n\r\nMaintenant pour compiler le serveur, il suffit de lancer la commande\r\nsuivante : \r\n\r\n``` powershell\r\n.\\node_modules\\.bin\\ngc -p .\\tsconfig.server.json\r\n```\r\n\r\n\r\nCependant le serveur doit également retourner les fichiers du client, il\r\nfaut donc également les générer. Lorsque l'on exécute la commande ng\r\nbuild, celle-ci supprime le répertoire dist, il vaut donc mieux\r\neffectuer ng build suivit de la commande webpack. Le plus simple est\r\nencore d'ajouter des scripts dans le fichiers package.json pour\r\neffectuer ces opérations séquentiellement.\r\n\r\n```json\r\n{\r\n  \"name\": \"angular-render-server\",\r\n  \"version\": \"0.0.0\",\r\n  \"license\": \"MIT\",\r\n  \"scripts\": {\r\n    \"ng\": \"ng\",\r\n    \"run\" : \"cd dist && node main.server.js && cd ..\",\r\n    \"start\": \"ng serve\",\r\n    \"build:all\": \"npm run build:app && npm run build:server \",\r\n    \"build:server\": \"webpack --config ./webpack.server.config.ts\",\r\n    \"build:app\": \"ng build\",\r\n    \"test\": \"ng test\",\r\n    \"lint\": \"ng lint\",\r\n    \"e2e\": \"ng e2e\"\r\n  },\r\n  \"private\": true,\r\n  \"dependencies\": {...},\r\n  \"devDependencies\": {...}\r\n}\r\n```\r\n\r\n \r\n\r\nAvec ces scripts supplémentaires, l'exécution de cette commande permet\r\nde générer l'application entièrement : \r\n\r\n``` powershell\r\nnpm run build:all\r\n```\r\n\r\nEt l'exécution de celle-ci permet de lancer le serveur : \r\n\r\n``` powershell\r\nnpm run run\r\n```\r\n\r\nAprès avoir lancé cette commande, il ne reste plus qu'à se rendre sur\r\nl'url http://localhost:8000 pour vérifier que tout fonctionne.\r\n\r\n![2017-08-26 00\\_32\\_39-Éditer article - Infinite\r\nBlogs.png](https://infiniteblogs.blob.core.windows.net:443/medias/51dc1d80-efc2-4a4d-9db6-b8466c523239_2017-08-26%2000_32_39-%C3%89diter%20article%20-%20Infinite%20Blogs.png)\r\n\r\nEt pour vérifier le bon fonctionnement du rendu coté serveur, il faut se\r\nrendre sur l'onglet \"Network\" des outils pour développeur de Chrome\r\net vérifier que le HTML retourné par le serveur correspond bien à du\r\nHTML pré-rendu et non simplement au contenu du fichier index.html.\r\n\r\n![2017-08-26 00\\_36\\_57-Éditer article - Infinite\r\nBlogs.png](https://infiniteblogs.blob.core.windows.net:443/medias/88699631-5cce-4972-beb7-2b1b706ae6a9_2017-08-26%2000_36_57-%C3%89diter%20article%20-%20Infinite%20Blogs.png)\r\n"
    },
    {
      "Id": 6,
      "Url": "Rendu-cote-serveur-dAngular-Part-13",
      "Title": "Rendu côté serveur d'Angular Part 1/3",
      "Description": "Cet article est le premier d'une série de 3 qui traiteront du sujet du rendu serveur d'une application Angular. Dans cette première partie, nous nous intéresserons à la partie théorique du sujet. Les deux parties suivantes traiteront de la mise en place avec Node.JS et ASP.NET Core.",
      "PublicationDate": "2017-08-09 00:00:00.000",
      "CategoryId": 2,
      "Tags": null,
      "MarkDownContent": "Cet article est le premier d'une série de 3 qui traiteront du sujet du\r\nrendu serveur d'une application Angular. Dans cette première partie,\r\nnous nous intéresserons à la partie théorique du sujet. Les deux parties\r\nsuivantes traiteront de la mise en place avec Node.JS et ASP.NET Core.\r\n\r\nPourquoi effectuer du rendu côté serveur ?\r\n------------------------------------------\r\n\r\nGrâce au rendu côté serveur, les applications web (Angular ou autre)\r\nprofitent de deux améliorations notables : \r\n\r\nLa première de ces améliorations concerne le référencement des pages\r\nd'une Single Page Application (SPA) dans les moteurs de recherche. En\r\neffet, les crawlers de moteur de recherche (les robots utilisé afin\r\nd'indexer le contenu des pages) n'exécutent pas toujours le\r\nJavaScript. Dans le cas d'une application Angular, si rien n'est prévu\r\npour ces crawlers, ceux-ci vont visiter une page ne contenant que le\r\ntexte \"Loading\\...\" et ce quelle que soit la page visitée. En effet la\r\npage index.html de base d'une application angular ne contient qu'une\r\ndiv avec ce texte et rien n'est ajouté si le javascript n'est pas\r\nactivé. Le rendu côté serveur permet de retourner une page avec le HTML\r\nde l'application pré-rempli, les crawlers peuvent donc visiter toutes\r\nles pages de notre application afin de les référencer convenablement.\r\nIls auront accès aux données de l'application.\r\n\r\nLe deuxième avantage notable de ce mécasime est le temps d'affichage de\r\nla page. En effet traditionnellement, avant qu'une page ne puisse\r\ns'afficher, il faut que le navigateur récupère tout le JavaScript,\r\nl'interprète et que le framework bootstrap notre application.\r\nLorsqu'on utilise le rendu côté serveur, le navigateur reçoit une page\r\nhtml déjà traitée et peux donc l'afficher directement. Il faut tout de\r\nmême attendre que tout le JavaScript soit téléchargé et que le framework\r\nait bootstrappé l'application avant que celle-ci ne devienne\r\ninteractive.\r\n\r\nPour illustrer ce deuxième avantage, j'ai effectué un test dans le\r\nnavigateur chrome en simulant un réseau 4G et en désactivant le cache.\r\nJ'ai également activé l'enregistrement des frames afin de pouvoir\r\ncomparer le temps d'affichage avec et sans rendu coté serveur. \r\n\r\n![performances rendu coté serveur angular\r\n](https://infiniteblogs.blob.core.windows.net:443/medias/b74b5364-c8cf-4ecf-8c58-c8200cd2c5b6_perf.png)\r\n\r\nOn peut voir dans cet exemple qu'il faut plus de 7 secondes à\r\nl'application avant d'afficher du contenu. C'est principalement le\r\ntemps de récupération des fichiers JavaScript par le navigateur. En\r\nrevanche lorsque l'application est rendue coté serveur, il ne faut que\r\n206ms avant que l'application ne puisse afficher du contenu. En\r\neffet, le serveur retourne un fichier HTML déjà rendu que le navigateur\r\nn'a qu'à afficher. Il faut en revanche attendre prêt de 7 secondes\r\navant que l'application ne soit interactive. \r\n\r\nComment ça marche ?\r\n-------------------\r\n\r\nLe principe fondamental de ce concept est que le client et le serveur\r\nexécutent la même application Angular. Ainsi lorsque le serveur retourne\r\nune page HTML pré-rendue, celle-ci est identique à ce que le client\r\naurait généré. Ainsi le client peut \"se greffer\" aux éléments déjà\r\ncréés par le serveur afin de ne pas regénérer une page.\r\n\r\nAfin que le serveur puisse générer le même HTML que le navigateur, il\r\ndoit connaître le code du client. Pour cela, client et serveur exécutent\r\nla même application, simplement avec des points d'entrée différents. Le\r\nHTML est donc identique, qu'il soit généré par le navigateur ou par le\r\nserveur Node.JS.\r\n\r\nCependant le module de base d'une application Angular importe le\r\nBrowserModule ainsi que d'autres modules incompatible avec l'exécution\r\nhors du navigateur. Afin de palier à ce problème il suffit de créer un\r\nmodule référencant le module principal de l'application et le module\r\nServerModule. Le serveur se servira de ce module afin de bootstrapper\r\nl'application.\r\n\r\n![schema fonctionnement rendu coté serveur\r\nAngular](https://infiniteblogs.blob.core.windows.net:443/medias/84188086-1566-421b-93e3-0f14f5ac6915_schem.png)\r\n\r\nLe schéma ci-dessus résume les étapes du chargement d'une application\r\navec rendu côté serveur. Tout d'abord, lorsqu'un utilisateur charge la\r\npage, le navigateur envoie une requête HTTP au serveur(1). Ensuite, le\r\nserveur Node.JS exécute l'application Angular en utilisant le module\r\ncréé à cet effet(2). Lors de cette étape, le serveur utilise\r\nl'application pour générer l'HTML correpondant à la requête fournie\r\npar le navigateur. Une fois généré, le serveur retourne cet HTML au\r\nnavigateur qui va pouvoir l'afficher tel quel (3). Enfin, le navigateur\r\nva charger l'application en utilisant son module principal (4).\r\n\r\nPour mettre ce mécanisme en plus il faut donc commencer par créer un\r\nmodule pour le serveur ne nécessitant pas l'exécution au sein d'un\r\nnavigateur. Ensuite il faut créer le serveur node.js se servant de ce\r\nmodule. Enfin, il faut créer la configuration de compilation de ce\r\nmodule. Ces différentes étapes seront décrites dans la suite de cette\r\nsérie.\r\n"
    },
    {
      "Id": 7,
      "Url": "Angular-2-Les-pipes",
      "Title": "Angular 2: Les pipes",
      "Description": "Un pipe est un élément du framework Angular permettant d'effectuer des transformations directement dans le template. Ils sont utilisés pour mettre en forme une date ou un nombre. Ils peuvent également être utilisés pour effectuer des filtres. Ce sont d'ailleurs les remplaçants des filtres d'AngularJS",
      "PublicationDate": "2016-07-20 00:00:00.000",
      "CategoryId": 2,
      "Tags": null,
      "MarkDownContent": "*Update le 04/12/2017 pour mettre à jour pour la version 5 du\r\nframework.*\r\n\r\nQu'est-ce qu'un pipe ?\r\n------------------------\r\n\r\nUn pipe est un élément du framework Angular permettant d'effectuer des\r\ntransformations directement dans le template. Ils sont utilisés pour\r\nmettre en forme une date ou un nombre. Ils peuvent également être\r\nutilisés pour effectuer des filtres. Ce sont d'ailleurs les remplaçants\r\ndes filtres d'AngularJS\r\n\r\nUtiliser un pipe\r\n----------------\r\n\r\nPour utiliser un pipe, il suffit de se servir de l'opérateur pipe (\\|)\r\nsur l'objet à transformer et d'ajouter le nom du pipe à utiliser.\r\n\r\n``` javascript\r\nimport { Component } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'sample',\r\n  template: `<p>{{now | date}}</p>`\r\n})\r\nexport class Sample {\r\n  now: Date = new Date();\r\n}\r\n```\r\n\r\nDans l'exemple ci-dessous, le pipe date est appliqué à l'objet `now`\r\nde type Date. Ainsi celui-ci sera ne sera pas affiché sous la forme\r\nJavaScript des dates (Tue Jul 12 2016 13:51:59 GMT+0200 (Romance\r\nDaylight Time)) mais sous une forme plus lisible utilisant la convention\r\nd'écriture américaine : Jul 12, 2016\r\n\r\nIl est, de plus, possible de passer des paramètres dans les pipes. Pour\r\ncela, il suffit simplement de les ajouter à la suite de l'appel au\r\npipe, séparés par des doubles points (:).\r\n\r\nPar exemple, `{{now | date:'MM/dd/yyyy'}} `deviendra 07/12/2016.\r\n\r\nCréer un Pipe\r\n-------------\r\n\r\nPour créer un pipe, il faut créer une classe implémentant l'interface\r\n`PipeTransform`. Cette interface ne contient qu'une seule méthode à\r\nimplémenter avec la signature suivante :\r\n`transform(value: any, ...args: any[]): any;`. C'est cette méthode qui\r\nest exécutée lorsque l'opérateur pipe est utilisé. Le paramètre value\r\nretourne la valeur de l'objet sur lequel est appliqué le pipe et args\r\nretournent tous les autres paramètres utilisés lors de l'appel au pipe.\r\n\r\nIl est également nécessaire d'appliquer le décorateur `Pipe` sur la\r\nclasse. Ce décorateur n'a qu'une seule métadonnée obligatoire qui\r\nreprésente le nom du pipe : name. C'est avec ce nom que le pipe est\r\nutilisable au sein d'un template.\r\n\r\n``` javascript\r\nimport { Pipe, PipeTransform } from '@angular/core';\r\n\r\n@Pipe({ name: 'sample' })\r\nexport class SamplePipe implements PipeTransform {\r\n  transform(input: string): string {\r\n        return `${input} from sample pipe`;\r\n  }\r\n}\r\n```\r\n\r\nDans cette exemple, j'ai simplement créé un pipe qui ajoute \" from\r\nsample pipe\" à la fin de toutes chaines caratères qui lui sont passées.\r\n\r\nPour pouvoir utiliser un pipe custom il est nécessaire d'ajouter la\r\nréférence au type dans la partie \"declarations\" du module dans lequel\r\non souhaite utiliser ce pipe :\r\n\r\n``` javascript\r\n@NgModule({\r\n  declarations: [\r\n   SamplePipe,\r\n   ...\r\n  ],\r\n  imports: [...],\r\n  providers: [...],\r\n  bootstrap: [AppComponent]\r\n})\r\nexport class AppModule { }\r\n```\r\n\r\nUne fois que le pipe est enregistré dans le module de l'application, il\r\npeut-être utilisé dans les templates de vos composants comme n'importe\r\nquel pipe du framework\r\n\r\n``` javascript\r\nimport { Component } from '@angular/core'; \r\n \r\n@Component({ \r\n    selector: 'sample', \r\n    template: `<p>{{hello | sample}}</p>`\r\n}) \r\nexport class Sample { \r\n    hello: string = `hello`; \r\n}\r\n```\r\n\r\nLe retour de ce composant sera \"hello from sample pipe\".\r\n\r\nPipe pure & impure\r\n------------------\r\n\r\nL'actualisation de la transformation est la plus grosse distinction\r\nentre les pipes d'Angular et les filtres d'AngularJS. En effet, par\r\ndéfaut, Angular ne réexécutera la méthode transform du pipe que\r\nlorsqu'il détectera une modification sur une valeur de type primitif,\r\nou un changement de référence pour les autres types. Autrement dit, il\r\nne réexécutera pas le pipe lorsqu'une propriété d'un objet est\r\nmodifiée, ou encore lorsqu'un élément est ajouté ou retiré d'un Array.\r\n\r\nCela permet à Angular d'assurer de bien meilleures performances que son\r\nprédécesseur, mais apporte également son lot de limitations. Il est\r\ncependant possible de retirer cette limitation. Pour cela, il faut\r\ntagger le pipe comme étant impure. Afin de rendre un pipe impure, il\r\nsuffit de rajouter pure: false dans le décorateur du pipe.\r\n\r\n``` javascript\r\n@Pipe({ name: \"sample\", pure: false }) \r\n```\r\n\r\nCependant, il vaut mieux dans la plupart des cas éviter l'utilisation\r\ndes pipes impures car ceux-ci influent beaucoup sur les performances.\r\nDans le cas d'un filtre, il est souvent possible remplacer un pipe\r\nimpure par un bind sur une nouvelle propriété dans le composant qui\r\ndevrait être mise à jour manuellement lorsque les entrées du filtre sont\r\nmodifiées.\r\n"
    },
    {
      "Id": 8,
      "Url": "middleware-en-aspnet-core",
      "Title": "Les middlewares en ASP.NET Core 1.0",
      "Description": "Dans le cadre d'une application ASP.NET Core 1.0, les middlewares composent la chaine de traitement (le pipeline) des requêtes HTTP. Ils interagissent sur la réponse et la requête HTTP.",
      "PublicationDate": "2016-06-13 00:00:00.000",
      "CategoryId": 1,
      "Tags": "asp.net core,middleware",
      "MarkDownContent": null
    },
    {
      "Id": 9,
      "Url": "rechargement-a-chaud-avec-aspnet-core-1",
      "Title": "Rechargement à chaud avec ASP.NET Core 1",
      "Description": "Le but de cette manipulation est de pouvoir profiter de la nouvelle fonctionnalité offerte par ASP.NET Core : le rechargement à chaud. Cette fonctionnalité permet de prendre en compte les modifications effectuées sur un projet directement à la sauvegarde et sans avoir à relancer manuellement le serveur applicatif.",
      "PublicationDate": "2016-02-16 00:00:00.000",
      "CategoryId": 1,
      "Tags": "dnx,asp.net core",
      "MarkDownContent": null
    },
    {
      "Id": 14,
      "Url": "Les-Barrels-Organisez-vos-imports-de-modules-es6",
      "Title": "Les Barrels : Organisez vos imports de modules es6",
      "Description": "Pour cet article, nous allons utiliser le langage typescript. Cependant, une grande partie de son contenu est également applicable aux projets javascript exploitant les features es6 du langage (à l'aide de Babel par exemple).",
      "PublicationDate": "2018-02-22 23:00:00.000",
      "CategoryId": 1002,
      "Tags": "es6,barel,import,typescript",
      "MarkDownContent": "Pour cet article, nous allons utiliser le langage **typescript**. Cependant, une grande partie de son contenu est également applicable aux projets javascript exploitant les features **es6** du langage (à l'aide de [Babel](https://babeljs.io/ \"babeljs\") par exemple).\r\n\r\nLa problèmatique\r\n----------------\r\n\r\nLorsque l'on developpe une application web, la tendance est à séparer les blocs techniques/fonctionnels en tant que **modules**. On utilise ensuite ces modules dans d'autres fichiers du projet.\r\n\r\nLorsque **l'application grandit**, généralement les dépendances de nos différents **modules grandissent également.** On se retrouve donc avec des fichiers **dont les dizaines de premières lignes** sont uniquement les **imports de ces dépendances**.\r\n\r\nVoici comment sont généralement exportés les modules d'une application. \r\n```typescript\r\n// services/service1.ts\r\nexport class Service1 { }\r\n\r\n// services/service2.ts\r\nexport class Service2 { }\r\n\r\n// services/service3.ts\r\nexport class Service3 { }\r\n```\r\nIci, on a 3 fichiers qui exportent chacun un service différent. Si jamais un autre module a besoin de ces 3 services, voici comment il va devoir s'y prendre :\r\n```typescript\r\n// index.ts\r\nimport { Service1 } from \"./services/service1\";\r\nimport { Service2 } from \"./services/service2\";\r\nimport { Service3 } from \"./services/service3\";\r\n```\r\nIci on ne se retrouve qu'avec trois lignes, cependant ces services appartiennent tous à la même catégorie fonctionnelle, ce sont les services de notre application. Est-ce qu'il ne serait pas intéressant de pouvoir effectuer un import directement sur le path _./services_ pour ces trois modules ?\r\n\r\nLes barrels\r\n-----------\r\n\r\nC'est exactement le principe d'un **barrel**. Il s'agit simplement d'un regroupement de modules afin qu'ils soient exposés depuis un seul et même module. Simplifiant ainsi la lecture du code de notre application. \r\n\r\nPour déclarer un barrel, il suffit de ré-exporter la totalité des modules que l'on veut exposer depuis ce dernier. Un exemple de code sera bien plus parlant : \r\n```typescript\r\n// services/index.ts\r\nexport * from './service1';\r\nexport * from './service2';\r\nexport * from './service3';\r\n```\r\n Et voilà, on a créé un barrel pour nos services. Ils peuvent maintenant s'importer de la manière suivante: \r\n```typescript\r\nimport { Service1, Service2, Service3 } from \"./services\";\r\n```\r\nNB: On n'est pas forcé de préciser le fichier dans le path ici (_./services/index_) car le résolveur de module va automatiquement chercher un fichier index si aucun n'est précisé.\r\n\r\nPour aller plus loin\r\n--------------------\r\n\r\nAttention, cette partie n'est valide plus que pour TypeScript.\r\n\r\nMême avec ces barrels, nos imports peuvent parfois avoir des formes un peu inattendues. En effet, ceux-ci étant relatifs, on peut parfois se retrouver avec imports de ce type : \r\n```typescript\r\nimport { Service1, Service2, Service3 } from \"../../../../services\";\r\n```\r\nEt encore, dans cet exemple on ne fait que remonter. Dans certain cas on peut se retrouver avec ce genre d'imports :\r\n```typescript\r\nimport { Service1, Service2, Service3 } from \"../../../../api/base/datasource/services\";\r\n```\r\nDans ce genre de cas, il est très facile de perdre patience, notamment lorsqu'on a à importer une dizaine de modules de la sorte avant de pouvoir commencer à developper le nouveau module.\r\n\r\nHeureusement, Typescript est là pour nous aider. En effet, il est possible de déclarer des alias au sein du fichier **tsconfig.json**. Ceux-ci vont permettre **de créer des chemins absolus** vers **un ou plusieurs module(s)**.\r\n\r\nPour créer un alias, il faut utiliser la propriété **paths** des **compilerOptions**. Attention, les chemins utilisés dans la propriété **paths** sont relatifs à la propriété **baseUrl**. Il est donc **obligatoire** de référencer une baseUrl si on veut utiliser les alias. \r\n\r\nLa déclaration d'alias se fait de la manière suivante : \r\n```json\r\n{\r\n    \"compilerOptions\": {\r\n        \"module\": \"commonjs\",\r\n        \"noImplicitAny\": true,\r\n        \"removeComments\": true,\r\n        \"preserveConstEnums\": true,\r\n        \"sourceMap\": true,\r\n        \"baseUrl\": \".\",\r\n        \"paths\": {\r\n            \"app-services\" : [\"./services\"]\r\n        }\r\n    },\r\n    \"files\": [\r\n        \"index.ts\"\r\n    ]\r\n}\r\n```\r\n Dans cet exemple, on déclare un alias de _\"./services\"_ vers _\"app-service\"_. Utiliser cet alias est aussi simple que ça: \r\n```typescript\r\nimport { Service1, Service2, Service3 } from \"app-services\";\r\n```\r\nLes plus attentifs l'auront remarqué, il s'agit ici d'un **import absolu**. Autrement dit, cet import sera toujours fait de la même façon, peu importe l'emplacement du fichier dans l'application.\r\n\r\nOn remarque également que l'alias est affecté avec un tableau. Cela veut dire qu'il est possible de créer des **alias** pour effectuer la résolution de **modules sur différents chemins**.\r\n\r\nCette fonctionnalité n'est utilisable que pour **les alias en pattern glob**. Par exemple, si on dispose d'un dossier _api/services_ dans lequel sont disposés des services d'api, il est possible de créer l'alias suivant : \r\n```json\r\n{\r\n    \"compilerOptions\": {\r\n        \"module\": \"commonjs\",\r\n        \"noImplicitAny\": true,\r\n        \"removeComments\": true,\r\n        \"preserveConstEnums\": true,\r\n        \"sourceMap\": true,\r\n        \"baseUrl\": \".\",\r\n        \"paths\": {\r\n            \"app-services/*\": [\r\n                \"./api/services/*\",\r\n                \"./services/*\"\r\n            ]\r\n        }\r\n    },\r\n    \"files\": [\r\n        \"index.ts\"\r\n    ]\r\n}\r\n```\r\nAvec cet alias, il sera possible d'importer les modules de la manière suivante : \r\n```typescript\r\nimport { ApiService1 } from \"app-services/api.service1\";\r\nimport { Service1 } from \"app-services/service1\";\r\n```\r\n**Happy coding !**"
    },
    {
      "Id": 15,
      "Url": "Background-sync-rendre-vos-applications-Offline-First",
      "Title": "Background sync : rendre vos applications \"Offline First\"",
      "Description": "Dans cet article nous allons voir comment utiliser les nouvelles API des services workers afin de rendre une application capable d'effectuer des synchronisations en tâche de fond avec le serveur même lorsqu'elle n'est pas lancée.",
      "PublicationDate": "2018-02-09 23:00:00.000",
      "CategoryId": 1002,
      "Tags": "pwa,background-sync,service-worker",
      "MarkDownContent": "Dans cet article nous allons voir comment utiliser les nouvelles API des **services workers** afin de rendre une application capable d'effectuer des synchronisations en tâche de fond avec le serveur **même lorsqu'elle n'est pas lancée**. \r\n\r\nQu'est-ce que le background sync ?\r\n----------------------------------\r\n\r\nUn des cas d'usage les plus fréquents sur mobile consiste à **effectuer une action simple, puis ranger son téléphone**. Par exemple, je reçois une notification Facebook m'indiquant que j'ai été taggé sur une photo, **je lance l'app, je like et je range mon téléphone.**\r\n\r\nSi l'utilisateur n'a pas de réseau à ce moment-là, **son expérience en sera dégradée car il ne pourra rien faire.** Il aura le choix entre garder son application ouverte jusqu'à ce que l'envoi au serveur ait pu être effectué, ou simplement **abandonner son action**. \r\n\r\nLe background sync permet de déférer la responsabilité au service worker de l’envoi au serveur de façon transparente pour l'utilisateur. Il faut donc passer la requête HTTP de l’application web au service worker. Ce dernier ayant une durée de vie plus longue que celle de l’application web, celui-ci pourra réessayer **même si l’utilisateur décide de fermer l’application**. Ce mécanisme de retry est d’ailleurs automatique avec l'API que nous allons utiliser.\r\n\r\nDans le cas d'une application utilisant ce mécanisme, l'utilisateur pourra donc ranger son téléphone **quel que soit l'état du réseau à ce moment-là**. \r\n\r\nIl est en revanche important de faire comprendre à l'utilisateur que l'application pourra se synchroniser **sans son intervention**.\r\n\r\nComment utiliser le background sync\r\n-----------------------------------\r\n\r\nCette fonctionnalité se basant sur un service worker, la permière chose à faire côté application est donc d'**enregister celui-ci**: \r\n```js\r\nnavigator.serviceWorker.register('/sw.js');\r\n```\r\nEnsuite, il faut récupérer l'objet représentant l'**enregistrement de ce service worker**. Pour cela on peut utiliser _navigator.serviceWorker.ready_. Cet objet est une Promise qui retourne l'instance de l'enregistrement (registration) courant. On peut ensuite l'utiliser pour demander l'enregistrement d'une synchronisation. \r\n```js\r\nnavigator.serviceWorker.ready.then(function(swRegistration) {\r\n  return swRegistration.sync.register('myFirstSync');\r\n});\r\n```\r\nLorsque cet appel est effectué il déclenche un événement 'sync' côté service worker. Sur cet événement, on retrouve une propriété tag.qui contient la chaîne de caractères passée au moment de l'enregistrement côté application (ici : \"myFirstSync\"). Pour traiter cette demande, il faut ensuite passer une Promise à la méthode waitUntil de l'événement. Si cette promise est résolue, alors la demande de synchronisation est réussie, si ne ce n'est pas le cas, **la demande de synchronisation a échoué et sera rententée plus tard**.\r\n```js\r\nself.addEventListener('sync', function(event) {\r\n  if (event.tag == 'myFirstSync') {\r\n    event.waitUntil(doSomeStuff());\r\n  }\r\n});\r\n```\r\nDans cet exemple, la méthode _doSomeStuff_ doit retourner une promise. L'évenement sync ne sera pas redéclenché pour le tag 'myFirstSync'  **tant que la promise retournée par la méthode doSomeStuff n'a pas été résolue**. Peu importe que l'application refasse des demandes de synchronisation ou non.\r\n\r\n**Il n'est pas possible de passer de la donnée dans les appels à la synchronisation**. Il faut donc pouvoir stocker ces données dans un storage accessible **côté application ET côté service worker.** Le Localstorage ne répond malheureusement pas à ces critères car il n'est pas disponible côté service worker. Il faut donc se rabattre du côté d'**IndexedDB** pour transmettre les data à envoyer au serveur. La méthode plus simple pour gérer des synchronisations à l'aide d'IndexedDB et de **gérer une queue de messages à envoyer**.\r\n\r\nOn ne va pas rentrer en profondeur dans l'utilisation d'IndexedDB dans cet article car le sujet est assez vaste et mériterait un post à lui seul. En attendant vous pouvez retrouver les guidelines de google à [cette adresse](https://developers.google.com/web/ilt/pwa/working-with-indexeddb \"Guidelines IndexedDB\")\r\n\r\nReste un point noir, la compatibilité. En effet seul **Google Chrome et Android** implémentent cette API pour le moment. \r\n\r\nVous êtes maintenant prêts à rendre vos application **\"Offline First\"** !"
    },
    {
      "Id": 16,
      "Url": "Angular-SSR-eviter-les-doubles-requetes-XHR",
      "Title": "Angular SSR: éviter les doubles requêtes XHR",
      "Description": "Dans cet article nous allons voir comment éviter que le client d'une application Angular refasse les mêmes requêtes XHR déjà effectuées par le serveur lors du Server-Side Rendering",
      "PublicationDate": "2018-03-12 23:00:00.000",
      "CategoryId": 2,
      "Tags": "angular,ssr,xhr",
      "MarkDownContent": "Dans cet article nous allons voir comment éviter que le client d'une application **Angular** rejoue les mêmes requêtes XHR déjà effectuées par le serveur lors du **Server-Side Rendering**.\r\n\r\nLa problématique\r\n----------------------------\r\n\r\nLorsqu'une application Angular est rendue coté serveur, celle-ci va s'initialiser une première fois dans un processus node afin de générer le HTML à envoyer au client. L'application va alors s’exécuter comme ça se serait le cas coté client. Des appels XHR vont donc être effectués afin de récupérer le contenu de l'application. Lorsque le client reçoit cet HTML, l'application va se réinitialiser dans le navigateur de l'utilisateur. Au cours de cette  ré-initialisation, les mêmes requêtes XHR vont donc être effectuées. Ces appels sont effectués **2 fois** (une coté serveur et une coté client). \r\n\r\nEtant donnée que ces requêtes ont déjà été effectuées coté serveur, récupérer ces données coté client pourrait être une opération synchrone. Dans ce cas, on peut s'assurer d'éviter l'effet de *flickering* qui arrive parfois lorsque l'application reprend la main coté client.\r\n\r\nLa solution\r\n-----------------\r\n\r\nPour régler ce problème, **Angular Universal** propose d'utiliser les modules suivants : [**ServerTransferStateModule**](https://angular.io/api/platform-server/ServerTransferStateModule) et [**BrowserTransferStateModule**](https://angular.io/api/platform-browser/BrowserTransferStateModule). Ceux-ci doivent s'insérer respectivement dans le module serveur et le module client de notre application\r\n\r\n```typescript\r\n//app.server.module.ts\r\n@NgModule({\r\n  bootstrap: [AppComponent],\r\n  imports: [\r\n    ServerModule,\r\n    ServerTransferStateModule,\r\n   ...\r\n  ]\r\n})\r\nexport class AppServerModule { }\r\n\r\n//app.browser.module.ts\r\n@NgModule({\r\n  bootstrap: [AppComponent],\r\n  imports: [\r\n    BrowserTransferStateModule\r\n    ,...\r\n  ],\r\n  providers: [ ... ]\r\n})\r\nexport class AppModule { }\r\n```\r\n\r\n\r\nCes modules vont permettre de créer un store entre le serveur et le client. Il devient donc possible de stocker dans ce store les résultats de requêtes XHR coté serveur afin de les réutiliser coté client. \r\n\r\nComment ça marche ?\r\n------------------------------------\r\n\r\nCe store fonctionne sur un principe de _clé-valeur_. Pour y accéder il faut se servir du service **TransferState**. Celui-ci expose les méthodes suivantes : \r\n 1. **_hasKey_ **:  Cette méthode permet de vérifier l'existence d'une clé dans le store\r\n 2. **_get_ **: Cette méthode permet de récupérer une valeur dans le store. On doit également passer une valeur par défaut si la clé est absente du store.\r\n 3. **_set_ **: Cette méthode permet de stocker une valeur dans le store en lui associant une clé.\r\n 4. **_remove_**: Cette méthode permet de retirer une valeur du store.\r\n\r\nPoint d'attention : La clé ne doit pas être de type string. Afin de créer une clé, on doit utiliser la méthode **_makeKey_**.\r\n\r\nCe service expose également des méthodes permettant de préciser de quelle manière doit être sérialisé le store, mais nous n'en parleront pas dans cet article.\r\n\r\nVoici un exemple concert d'utilisation (la récupération des articles pour la page d'accueil de ce blog) : \r\n\r\n```typescript\r\nimport { TransferState, makeStateKey } from '@angular/platform-browser';\r\nimport { of } from 'rxjs/observable/of';\r\nimport { tap } from 'rxjs/operators';\r\n\r\n@Injectable()\r\nexport class BlogService {\r\n\r\n  constructor(private http: HttpClient, private transferState: TransferState) { }\r\n\r\n  getPosts(): Observable<PostList> {\r\n    const key = makeStateKey('postList');\r\n    if (this.transferState.hasKey(key)) {\r\n      return of(this.transferState.get(key, null));\r\n    }\r\n    return this.http.get<PostList>(`${environment.apiUrl}/blog`)\r\n      .pipe(tap(postList => {\r\n        this.transferState.set(key, postList);\r\n      }));\r\n  }\r\n}\r\n```\r\nDans cet exemple, on inject le service **TransferState**. Ensuite, dans la méthode **_getPosts_** on créé une clé pour le store. Puis on vérifie la présence de cette clé dans le store via la méthode **_hasKey_**. \r\n\r\nSi elle est présente, c'est qu'on se trouve coté client. On peut donc directement retourner la valeur stockée dans le store en utilisant la méthode **_get_** du service **TransferState**. On utilise ici l'opérateur _**of**_ afin de créer un Observable à partir d'une valeur.\r\n\r\nSi la clé n'est pas présente dans le store, c'est qu'on se trouve coté serveur. On effectue alors la requête HTTP. Mais avant de la retourner, on utilise l'opérateur _**tap**_ de rxjs. Celui permet d'effectuer une action sans influence sur le résultat de l'observable. Ici, on souhaite ajouter ce dernier dans le store afin de le rendre accessible coté client. Pour cela, on utilise la méthode **_set_** on lui fournissant la clé précédemment créée et la valeur à stocker.\r\n\r\nUne fois cette mécanique mise en place, on peut observer que la requête HTTP n'est plus effectuée coté client. Celui-ci se servant des données du store.\r\n\r\nTechniquement, lorsqu'un objet est mis dans le store, une balise script avec le type _\"application/json\"_ est ajouté au DOM. Celle-ci contient les données sérialisées du store. L'exemple précédent génére donc ce DOM en plus: \r\n\r\n![Sample de HTML](https://i.imgur.com/hOopvMI.png)\r\n\r\nVous pouvez d'ailleurs l'observer en utilisant les outils de débogage de Chrome directement sur cet article en rafraichissant la page.\r\n\r\nBonus\r\n---------\r\n\r\nEffectuer cette mécanique sur chacun des services d'une application, peut-être fastidieux. Un moyen de rendre la tâche générique est de passer pour un _Intercepteur HTTP_. La team Angular Universal a d'ailleurs eu cette idée et l'a intégré au framework. Pour l'utiliser, c'est très simple, il suffit d'importer le module **TransferHttpCacheModule** à la place du module **BrowserTransferStateModule**\r\n\r\n ```typescript\r\n//app.browser.module.ts\r\n@NgModule({\r\n  bootstrap: [AppComponent],\r\n  imports: [\r\n    //BrowserTransferStateModule\r\n    TransferHttpCacheModule\r\n    ,...\r\n  ],\r\n  providers: [ ... ]\r\n})\r\nexport class AppModule { }\r\n```\r\n\r\nEn changeant simplement cet import, il n'est maintenant plus nécessaire de manipuler le service **TransferState**. Les requêtes HTTP sont automatiquement ajoutées au store. \r\n\r\nAttention tout de même si vous utilisez le moteur de rendu ASP.NET. En effet, le module **TransferHttpCacheModule** ne fonctionnait pas jusqu'à la version _**5.0.0-beta.6**_ du package _**@nguniversal/common**_ sortie à la fin du mois de février. Pensez donc à vérifier votre **package.json** si vous êtes concerné :)\r\n\r\n**Happy Coding**"
    },
    {
      "Id": 19,
      "Url": "Debugguez-Angular-dans-VSCode",
      "Title": "Debugguez Angular dans VSCode",
      "Description": "Tirez profit des api de débogage de Chrome et VSCode pour placer des points d'arrêts directement dans votre IDE.",
      "PublicationDate": "2018-03-29 22:00:00.000",
      "CategoryId": 2,
      "Tags": "typescript,vscode,angular,debug",
      "MarkDownContent": "![angular love vscode](https://i.imgur.com/hdXCSzm.png)\r\n\r\nDans cet article nous allons voir comment mettre en place un setup permettant de lancer une application Angular (ou tout autre type d'application utilisant un watcher pour effectuer la compilation lorsque le code change), de lancer le navigateur chrome en mode debug et de brancher le debugger à VSCode, le tout en appuyant sur une seule touche.\r\n\r\nPour ce faire, nous allons devoir créer une configuration de lancement (fichier launch.json) qui servira à lancer chrome et se brancher sur ses api de debug. Cette configuration s’appuiera sur une tâche (fichier tasks.json) qui s'occupera de la compilation de notre application.\r\n\r\n## tasks.json\r\n\r\nLa première étape est de créer une tâche dans VSCode. Pour cela, il suffit d'utiliser la commande *Tasks: Configure default Build task*. Cette commande peut-être trouvée en appuyant sur la touche F1, puis en effectuant une recherche.\r\n\r\n![Tasks  Configure default Build task ](https://i.imgur.com/yh9mYFj.png)\r\n\r\nUne fois la commande sélectionnée, on est invité à choisir une tâche. VSCode va nous proposer les différents scripts disponibles dans notre fichier package.json ainsi des scripts de compilation typescript pour chaque fichier tsonfig.json dans le projet. Dans notre cas, la tache qui nous intéresse est npm : start. \r\n\r\n![npm start](https://i.imgur.com/uFCkyiN.png)\r\n\r\nUne fois selectionnée, un fichier tasks.json est créé dans le dossier .vscode. Ce fichier contient un json représentant les différentes taches configurées pour le projet. Dans la tache qui vient d'être créée, nous allons ajouter un identifieur, celui-ci permettra de référencer la tache plus tard. Etant donné que cette tache n'a pas de fin ( elle tournera jusqu'à annulation), il faut le préciser dans la description de la tache. Pour celà, il faut ajouter la propriété **`isBackground`** à true. \r\n\r\nÀ ce stade, le fichier doit ressembler à ça : \r\n\r\n```json\r\n{\r\n    \"tasks\": [\r\n        {\r\n            \"identifier\": \"start angular\",\r\n            \"type\": \"npm\",\r\n            \"script\": \"start\",\r\n            \"path\": \"Blog.Web\\\\angular\\\\\",\r\n            \"group\": {\r\n                \"kind\": \"build\",\r\n                \"isDefault\": true\r\n            },\r\n            \"isBackground\": true\r\n        }\r\n    ]\r\n}\r\n```\r\nIl faut maintenant pouvoir fournir a VSCode un moyen de savoir que la compilation est terminée, pour cela, on va se servir de la propriété **`problemMatcher`** . Cette propriété prend en paramètre un tableau d'objets décrivant comment repérer les erreurs et quel est leur format. Pour les tâches qui fonctionnent en background, on peut également décrire quand la compilation commence et quand elle se termine. Pour cela il faut remplir un objet dans la propriété **`background`** de la manière suivante : \r\n\r\n```json\r\n    \"problemMatcher\": [\r\n        {\r\n        \"background\": {\r\n            \"activeOnStart\": true,\r\n            \"beginsPattern\": \"<Regex indiquant que la compilation commence>\",\r\n            \"endsPattern\": \"<Regex indiquant que la compilation est terminée>\"\r\n          }\r\n       }\r\n    ]\r\n```\r\n\r\nDans le cas d'Angular, ces regex fonctionnent\r\n```json\r\n    \"problemMatcher\": [\r\n        {\r\n        \"background\": {\r\n            \"activeOnStart\": true,\r\n            \"beginsPattern\":  \"\\\\*\\\\* NG Live Development Server is listening on localhost:4200, open your browser on http://localhost:4200/ \\\\*\\\\*\",\r\n            \"endsPattern\": \"webpack: Compiled successfully\\\\.\"\r\n          }\r\n       }\r\n    ]\r\n```\r\nÀ vous d'adapter pour votre compilation.\r\n\r\n\r\nPour que la tâche puisse être traquée, il faut également lui fournir le pattern de détection d'erreur. Ce n'est pas le sujet du jour, alors je vais simplement vous le donner pour un output webpack de compilation typescript. \r\n\r\n```json\r\n {\r\n      \"regexp\": \"ERROR in \\\\[at-loader\\\\] ([^:]*):(\\\\d+):(\\\\d+)\",\r\n      \"file\": 1,\r\n      \"line\": 2,\r\n      \"column\": 3\r\n}\r\n```\r\nCe pattern est à placer dans le tableau de la propriété **`pattern`** du **`problemMatcher`**. \r\n\r\nVoici donc ce à quoi doit ressembler votre fichier task.json : \r\n```json\r\n{\r\n    \"tasks\": [\r\n        {\r\n            \"identifier\": \"start angular\",\r\n            \"type\": \"npm\",\r\n            \"script\": \"start\",\r\n            \"path\": \"Blog.Web\\\\angular\\\\\",\r\n            \"group\": {\r\n                \"kind\": \"build\",\r\n                \"isDefault\": true\r\n            },\r\n            \"isBackground\": true,\r\n            \"problemMatcher\": [\r\n                {\r\n                    \"owner\": \"custom\",\r\n                    \"fileLocation\": \"relative\",\r\n                    \"pattern\": [\r\n                        {\r\n                            \"regexp\": \"ERROR in \\\\[at-loader\\\\] ([^:]*):(\\\\d+):(\\\\d+)\",\r\n                            \"file\": 1,\r\n                            \"line\": 2,\r\n                            \"column\": 3\r\n                        },\r\n                        {\r\n                            \"regexp\": \"TS(.*)\",\r\n                            \"message\": 1\r\n                        }\r\n                    ],\r\n                    \"background\": {\r\n                        \"activeOnStart\": true,\r\n                        \"beginsPattern\": \"\\\\*\\\\* NG Live Development Server is listening on localhost:4200, open your browser on http://localhost:4200/ \\\\*\\\\*\",\r\n                        \"endsPattern\": \"webpack: Compiled successfully\\\\.\"\r\n                    }\r\n                }\r\n            ]\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nLa configuration de notre tâche est bonne, on peut passer à la configuration de lancement.\r\n\r\n## launch.json\r\n\r\nPour créer la configuration du lancement, il faut utiliser la commande *Open launch.json file* :\r\n\r\n![open launch.json](https://i.imgur.com/4SfrVz5.png)\r\n\r\nUne fois cette commande tapée, on est invité à choisir un type d’environnement de configuration. Dans notre cas, il faut sélectionner le type **`Chrome`** \r\n\r\n![select chrome environnement](https://i.imgur.com/EonrH50.png)\r\n\r\nCela va créer un fichier launch.json dans le dossier .vscode. Ce fichier est presque bon en soit, il nous faut simplement modifier l'url (pour lancer sur le port 4200 et le 8080 proposé) et ajouter une **`preLaunchTask`**. Dans la propriété **`preLaunchTask`**, il faut spécifier l'identifieur de la tache créée dans le fichier tasks.json. Si votre projet Angular n'est pas à la racine de votre projet, vous devrez également modifier la propriété **`webRoot`** pour cibler votre projet.\r\n```json\r\n{\r\n    \"version\": \"0.2.0\",\r\n    \"configurations\": [\r\n        {\r\n            \"type\": \"chrome\",\r\n            \"request\": \"launch\",\r\n            \"name\": \"Launch Chrome against localhost\",\r\n            \"url\": \"http://localhost:4200\",\r\n            \"webRoot\": \"${workspaceFolder}/Blog.Web/angular\",\r\n            \"preLaunchTask\": \"start angular\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nMaintenant tout est prêt pour débugger votre application directement dans VSCode, tout ce qu'il reste à faire est appuyer sur F5  !\r\n\r\n![debugger en action](https://i.imgur.com/olPXLK5.png)\r\n\r\n**Happy debugging !**"
    },
    {
      "Id": 22,
      "Url": "StencilJs-Quest-ce-que-cest",
      "Title": "StencilJs, Qu'est-ce que c'est ?",
      "Description": "Dans cet article, je vous propose d'explorer les possibilités et les enjeux de StencilJs, le framework Web de Ionic basé sur les Web Components",
      "PublicationDate": "2018-05-08 00:00:00.000",
      "CategoryId": 1002,
      "Tags": "stencil,stenciljs,ionic,web component",
      "MarkDownContent": "Stencil est le nouveau framework web développé par la team Ionic. Il est basé sur les standards du web, mais ressemble fortement à un mélange de React et Angular dans la syntaxe. \r\n\r\n![logo stencil](https://i.imgur.com/2iWKeqv.png)\r\n\r\n## Encore un framework Js ?!\r\n\r\nHistoriquement, la team Ionic travaillait essentiellement avec le framework AngularJs (puis Angular) afin de fournir une interface mobile proche du native. Pour ce faire, ils mettaient à disposition une librairie de composants Angular ainsi qu'un tooling permettant d'encapsuler une application Angular dans une application Cordova. \r\n\r\nLa nouvelle vision de Ionic est maintenant d'être **framework agnostique**. Leur objectif est que Ionic puisse être utilisé aussi bien dans une application React, Angular que VueJs. Afin de parvenir à cet objectif, ils ont donc développé leur propre framework web, Stencil. Celui-ci est basé sur les standards du web, ainsi, un composant Stencil compilé sera utilisable n'importe où (y compris en Vanilla).\r\n\r\n## Web Component \r\n\r\nLe standard sur lequel s'appuie Stencil est celui des [Web Components](https://www.webcomponents.org/). \r\nAinsi, un composant Stencil, une fois buildé, peut donc s'utiliser de manière native dans le navigateur.\r\n\r\nLa déclaration d'un composant est assez simple, notamment pour les développeurs ayant travaillé avec Angular et React. \r\n\r\nVoici un exemple de déclaration de composant: \r\n``` typescript\r\nimport { Component, State,Prop } from '@stencil/core';\r\nimport { Todo } from '../models/todo';\r\n\r\n\r\n@Component({\r\n  tag: 'my-todo',\r\n  styleUrl: 'todo.scss'\r\n})\r\nexport class TodoComponent {\r\n\r\n  @Prop() todoName: string;\r\n  @State() public todos: Todo[] = [];\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <h1>{this.todoName}</h1>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\nOn retrouve ici l'utilisation du décorateur **`Component`** (comme dans Angular) permettant de définir le tag html du composant et ou se situe sa feuille de style. On retrouve également la notion de **`State`** et  de **`Prop`** (comme dans React). Les propriétés décorées par **`State`** déclenchent une ré exécution de la méthode **`render`** lorsque leurs référence est changées. Les propriétés décorées par **`Prop`** sont récupérées en tant qu'input du composant, elles redéclenchent également un rendu lorsqu'elles sont modifiées. Enfin, le template des composants est rédigé en JSX. Tout comme pour React, celui-ci est généré via la méthode **`render`** du composant.\r\n\r\nIl est également possible d’émettre des événements. Pour celà, il faut ajouter une propriété de type **`EventEmitter`** (comme dans Angular) et d'y ajouter le décorateur **`Event`**. Ensuite, pour déclencher l'évenement, il faut appeler la méthode **`emit`** sur cette propriété en lui passant en paramètre l'objet que l'on souhait envoyer via l'event.\r\n\r\n``` typescript\r\nexport class TodoComponent  {\r\n\r\n  @Event() todoCompleted: EventEmitter;\r\n\r\n  todoCompletedHandler(todo: Todo) {\r\n    this.todoCompleted.emit(todo);\r\n  }\r\n}\r\n```\r\n\r\nLes événements levés par cette propriété pourront être écoutés via la méthode **`addEventListener('todoCompleted' ,...)`** comme n'importe quel autre événement natif.\r\n\r\nPour un exemple de composant plus complet, vous pouvez aller jeter un oeil à ce repository : [stencil-todo](https://github.com/Willovent/stencil-todo). Un version [live](https://willovent.github.io/stencil-todo/) est également disponible pour voir le rendu.\r\n\r\n## Stencil App\r\n\r\nStencilJs permet donc de créer des composants, cependant, afin d'être considéré comme un framework web, celui-ci doit offrir plus de fonctionnalités. \r\nAfin de construire une Single Page Application, une des briques essentielle est le router.\r\nCe router contient  la plupart des fonctionnalités que l'on peut attendre de ce type de brique et ne demande que très peu de configuration. Il va par exemple gérer automatiquement le lazyloading des composants de l'application.\r\n\r\nLe framework contient également une brique permettant de gérer le state de l'application (nommé **`context`** dans StencilJs), une notion rappelant grandement Redux.\r\n\r\nCes spécificités feront l'objet d'un prochain article, plus technique.\r\n\r\n## Tooling\r\n\r\nIonic a volontairement réduit le tooling de son framework. Cependant, pas d’inquiétude, il ne sera pas nécessaire d'écrire un fichier de configuration webpack  pour chaque application ou composant.\r\n\r\nIl n'y a pas de cli à installer en global, comme pour Angular, mais il existe différentes manières de scaffolder son application. \r\n\r\nCelle proposée par le \"Getting Started\" de Stencil est simplement de cloner un repository contenant une application vierge sur github. Il est également possible d'utiliser une générateur yeoman pour arriver à ses fins.\r\n\r\nQuelle que soit la manière dont l'application est scaffoldée, les commandes permettant de lancer le serveur de développement et de build l'application se trouve directement dans le fichier package.json (respectivement `npm start` et `npm run build`)\r\n\r\nIl est assez facile de commencer à développer, même si en tant que développeur Angular j'aurais apprécié quelques générateurs.\r\n\r\n## Compatibilité \r\n\r\nLe format de sortie de Stencil étant des web components, il faut donc jeter un œil à la compatibilité de ceux-ci: \r\n![Compatibilité Web component](https://i.imgur.com/ydjN6wD.png)\r\n\r\nComme on peut le remarquer dans ce tableau, certaines fonctionnalités des web components  nécessitent un polyfill pour fonctionner sur Edge et Firefox. Cependant, Stencil se charge de récupérer le polyfill de 20kb(gzipped) \r\n uniquement lorsqu'il est nécessaire.\r\n\r\nStencil est donc utilisable dès aujourd'hui et la prise en main est extrêmement rapide pour un développeur web ayant déjà travaillé avec des frameworks web modernes. Il n'est pas forcement le candidat idéal lorsque l'on souhaite commencer le développement d'une SPA, notamment à cause son manque de maturité. Cependant si l'objectif est de partager des composants graphiques dans des projets n'utilisant pas tous le même framework, il devient alors la solution parfaite. \r\n\r\n**Happy Codding**"
    },
    {
      "Id": 24,
      "Url": "decorateur-typescript-comment-reexecuter-une-methode-en-se-basant-sur-un-observable",
      "Title": "Decorateur typescript: comment réexécuter une méthode en se basant sur un Observable",
      "Description": "Le but de ce poste est de voir de quelle manière réexécuter une méthode lors qu'un Observable émet une nouvelle valeur en utilisant un décorateur.",
      "PublicationDate": "2018-06-25 00:00:00.000",
      "CategoryId": 1002,
      "Tags": "typescript,décorateur",
      "MarkDownContent": "Cet article nécessite des connaissances de base sur les décorateurs. Si vous n'êtes pas à l'aise avec ce concept, je vous conseil l'article [A la découverte des décorateurs TypeScript](https://sebastienollivier.fr/blog/javascript/a-la-decouverte-des-decorateurs-typescript) de Sébastien Ollivier.\n\nLe but de ce poste est de voir de quelle manière réexécuter une méthode lorsqu'un `Observable` émet une nouvelle valeur en utilisant un décorateur.\n\nLe cas d'utilisation qui a motivé l'écriture de ce décorateur est le suivant : \nJe dois réexécuter des appels HTTP lorsque l'utilisateur change la langue de l'interface. En effet, certaines données sont contextuelles à la langue de l'utilisateur. Lorsque ce dernier la change, il est donc nécessaire de récupérer les données contextuelles à cette nouvelle langue.\n\n## Étape 1: Spécifier le ou les observables qui doivent déclencher une réexécution\n\nPour cela, on utilise un décorateur qui va stocker le nom d'une propriété de type `Observable` directement dans le prototype de la classe en utilisant un décorateur : \n\n```typescript\nconst TRIGGER_KEY = '__async_decorator_trigger_key__';\n\nexport function AsyncTrigger() {\n  return function(target: Object, propertyKey: string | symbol) {\n    if (!target[TRIGGER_KEY]) {\n      target[TRIGGER_KEY] = [];\n    }\n    target[TRIGGER_KEY].push(propertyKey);\n  };\n}\n```\n\nDans ce morceau de code, on stocke le nom dans la propriété dans un tableau dans le prototype de la classe. On le fait dans un tableau afin d'avoir la possibilité d'utiliser plusieurs triggers. \n\n## Étape 2: s'abonner au changement. \n\nLa logique est simple: on merge les observables stockés dans le prototype et quand l'un d'eux émet une nouvelle valeur, on réexécute la méthode sur laquelle le décorateur a été appliqué. On doit en revanche faire tout cela dans le contexte d'exécution de la méthode (en replaçant `descriptor.value`), ce qui implique que la méthode doit être appelée dans le constructeur de la classe pour que le mécanisme se met en place.\n\n```typescript\nexport function Async() {\n  return function(_target: any, _propertyKey: string, descriptor: PropertyDescriptor) {\n    // On stocke une référence vers la méthode originale\n    const oldFunc: Function = descriptor.value;\n\n    // On remplace la méthode originale par notre mécanisme\n    descriptor.value = function(...args) {\n      if (this[TRIGGER_KEY]) {\n        // On merges les observables stockés dans le prototype\n        const observable = merge(...this[TRIGGER_KEY].map(x => this[x]));\n        // On s'abonne au merge et on déclenche la méthode original lorsque qu'une nouvelle valeur est émise\n        const subscription = observable.subscribe(() => oldFunc.apply(this, args));\n      } else {\n        // Si pas de trigger: warning dans la console\n        console.warn('Async decorator used with no trigger');\n        oldFunc.apply(this, args);\n      }\n    };\n  };\n}\n```\n\nAttention cependant, on créer ici une suscription qui n'est pas `unsubscribe`. A vous d'implémenter cette notion en fonction du cycle de vie de vos classes. Pour un composant Angular par exemple, il est simple de se greffer sur la méthode `ngOnDestroy` du composant: \n\n```typescript\nexport function Async() {\n  return function(_target: any, _propertyKey: string, descriptor: PropertyDescriptor) {\n    const oldFunc: Function = descriptor.value;\n\n    descriptor.value = function(...args) {\n      if (this[TRIGGER_KEY]) {\n        const observable = merge(...this[TRIGGER_KEY].map(x => this[x]));\n        const subscription = observable.subscribe(() => oldFunc.apply(this, args));\n\n        const oldDestroy = this.ngOnDestroy;\n        if (!oldDestroy) {\n          console.error('Usage of Async without implementing ngOnDestroy');\n        }\n\n        this.ngOnDestroy = function() {\n          subscription.unsubscribe();\n          oldDestroy.apply(this);\n        };\n      } else {\n        console.warn('Async decorator used with no trigger');\n        oldFunc.apply(this, args);\n      }\n    };\n```\n\n## Étape 3: Utilisation\n\nL'utilisation de ces décorateurs se fait en 3 points :\n1. On applique le décorateur `@AsyncTrigger()` sur une ou plusieurs propriétés de type `Observable`\n2. On applique le décorateur `@Async()` sur la ou les méthodes que l'on veut réexécuter lorsqu'un des observables émet une valeur.\n2. On appelle les méthodes décorées par `@Async()` dans le constructeur de la classe (ou dans la méthode `ngOnInit` dans le cas d'une application Angular).\n\n```typescript\n@Component({...})\nexport class MyComponent implements OnInit, OnDestroy {\n\n  @AsyncTrigger() languageTrigger = this.i18nService.languageChanged$;\n\n  constructor(private i18nService: I18nService) {}\n\n  ngOnInit() {\n    this.loadLanguageRelatedData();\n  }\n\n  ngOnDestroy() { }\n\n  @Async()\n  private loadLanguageRelatedData() {...}\n\n}\n```\n\n\nDans cet exemple, la méthode `loadLanguageRelatedData` est réexécutée à chaque fois que l'Observable `languageTrigger` émet une nouvelle valeur. \n\n__Happy coding !__"
    },
    {
      "Id": 26,
      "Url": "generation-dune-font-dicones",
      "Title": "Génération d'une font d'icônes",
      "Description": "Découvrez comment générer une font pour stocker les icônes de vos applications de manière efficace et simple.",
      "PublicationDate": "2018-07-23 00:00:00.000",
      "CategoryId": 1002,
      "Tags": "font,icônes,police",
      "MarkDownContent": "\n\nAvant de voir comment, on va se pencher sur pourquoi utiliser une police de caractère pour stocker des icônes.\n\n\n## Pourquoi générer votre propre font d'icônes ?\nLe premier avantage notable est au niveau de la récupération des icônes de l'application. En utilisant une font, il va être possible de récupérer toutes les icônes en une requête HTTP. Sur une grosse application contenant un grand nombre d'icônes, cela permet d'améliorer l'affichage initial de notre application.\n\nEnsuite, l'utilisation permet de manipuler les icônes bien plus simplement. On va pouvoir modifier la taille, la couleur ou encore les ombres sur nos icônes avec de simples règles CSS. Il devient alors facile d'ajouter des comportements dynamiques sur les icônes ( en utilisant les pseudo-selecteurs `:hover` ou `:disabled` par exemple).\n\nBeaucoup d'entreprises ont bien compris tous ces avantages et proposent maintenant des polices d'icônes _ready to use_  à l'instar de [fontawesome](https://fontawesome.com/) ou encore [glyphicons](http://glyphicons.com/). Seulement ces polices contiennent souvent beaucoup d'icônes que vous n'allez pas utiliser (mais tout de même faire télécharger à vos clients). De plus, ces polices ne sont pas customisables, donc si vous comptiez ajouter un icône à celle-ci, ça ne sera pas possible. Enfin, bien qu'elles possèdent généralement un tier gratuit, la plupart vous feront payer l'utilisation complète. Dans ce cas, pourquoi ne pas générer votre police de caractère ?\n<center><img src=\"https://i.imgur.com/6JKHf6k.png\" alt=\"font illustration\"></img></center>\n\n## Comment générer votre propre font d'icônes\n\nLe secret réside dans un simple package npm, dont l'utilisation est vraiment très simple : [icon-font-generator](https://github.com/Workshape/icon-font-generator)\n\nSon utilisation est très simple, une fois installé il suffit de lancer la commande suivante :  \n```powershell\nicon-font-generator [svg-icons-glob] -o [output-dir]\n``` \nDonc pour générer une font d'icônes dans le dossier `./assets/fonts` depuis des images format svg dans un dossier `./icons` il faut utiliser \n```powershell\nicon-font-generator icons/*.svg -o assets/fonts\n```\n\nUne fois cette commande effectuée, il ne reste plus qu'à référencer la font générée dans votre application. Pour cela il faut référencer le fichier icons.css qui se situe dans le dossier précisé lors de l’exécution de la commande.\n\nCela peut se faire via un import dans un fichier sass/less : \n```css\n@import './assets/font/icons.css';\n```\nOu encore directement dans l'html : \n```html\n<html>\n <head>\n  <link href=\"assets/font/icons.css\" rel=\"stylesheet\">\n </head>\n</html>\n```\n\nUne fois référencée, on peut enfin commencer à utiliser cette font. \n\nPour insérer un des icones qui se situent dans notre font, il faut ajouter au DOM un élément `i`  avec la classe `icon-[nom de l'image]`. Par exemple, pour insérer un icône qui était nommé `home.svg`, on peut maintenant l'insérer avec le DOM suivant: \n\n```html\n<i class=\"icon-home\"></i>\n```\n\nEt voilà, vous pouvez maintenant utiliser votre propre font d'icône partout dans votre application ! \n\nIl est même possible de personnaliser les préfix, noms de fichiers etc... de votre font en approfondissant un peu plus les options de ce paquet npm !\n\n```md\nExample : icon-font-generator src/*.svg -o dist\n\nOptions:\n  -o, --out        Output icon font set files to <out> directory\n  -n, --name       Name to use for generated fonts and files (Default: icons)\n  -s, --silent     Do not produce output logs other than errors (Default: false)\n  -f, --fontspath  Relative path to fonts directory to use in output files (Default: ./)\n  -c, --css        Generate CSS file if true (Default: true)\n  --csspath        CSS output path (Defaults to <out>/<name>.css)\n  --csstp          CSS handlebars template path (Optional)\n  --html           Generate HTML preview file if true (Default: true)\n  --htmlpath       HTML output path (Defaults to <out>/<name>.html)\n  --types          Font types - (Defaults to 'svg, ttf, woff, woff2, eot')\n  --htmltp         HTML handlebars template path (Optional)\n  -j, --json       Generate JSON map file if true (Default: true)\n  --jsonpath       JSON output path (Defaults to <out>/<name>.json)\n  -p, --prefix     CSS classname prefix for icons (Default: icon)\n  -t, --tag        CSS base selector for icons (Default: i)  \n  --normalize      Normalize icons sizes (Default: false)\n  --round          Setup SVG rounding (Default: 10e12)\n  --descent        Offset applied to the baseline (Default: 0)\n  --mono           Make font monospace (Default: false)\n  --height         Fixed font height value\n  --center         Center font horizontally\n```\n\n__*Happy Coding !*__"
    },
    {
      "Id": 30,
      "Url": "mon-streameur-prefere",
      "Title": "Mon streameur préféré !",
      "Description": "coucou",
      "PublicationDate": "2039-09-05 00:00:00.000",
      "CategoryId": 1002,
      "Tags": "kevin",
      "MarkDownContent": "\n## Je vous présente mon streameur préféré, en direct de la __LFP__ !\n<iframe src=\"https://stackblitz.com/edit/modal-demo?embed=1&file=src/app/app.component.ts\" width=\"100%\" height=\"500px\"></iframe>"
    },
    {
      "Id": 31,
      "Url": "creer-un-gestionnaire-de-modales-avec-angular",
      "Title": "Créer un gestionnaire de modales avec Angular",
      "Description": "Cet article explique comment créer un gestionnaire de modales pas à pas.",
      "PublicationDate": "2019-01-21 00:00:00.000",
      "CategoryId": 2,
      "Tags": "angular,modale,cdk",
      "MarkDownContent": "Dans cet article nous allons voir comment créer un gestionnaire de modales dans angular sans utiliser de librairie externe. \n\nL’implémentation recherchée consiste à pouvoir instancier un composant via un service et que celui-ci se retrouve dans le DOM avec un backdrop (toile de fond) et un bouton permettant la fermeture de ce dernier.\n\nPour cela, 3 étapes seront nécessaires : \n1. Créer un composant qui contient le backdrop ainsi que le bouton de fermeture. Ce conteneur servira également de host pour les composants de type modale que nous voudrons instancier. \n2. Créer un service qui puisse être utilisé n'importe où dans l'application afin d'instancier une modale.\n3. Ecouter ce service dans l'`AppComponent` afin d'y gérer l'injection du conteneur.\n\n## ModalComponent\n\nDans ce composant nous allons avoir besoin d'un **backdrop**, d'un **conteneur** pour la modal, d'un **template** pour insérer le composant que l'on veut injecter et enfin d'un **bouton de fermeture** de la modale : \n``` html \n<div class=\"backdrop\" (click)=\"onClose()\"></div>\n<div class=\"modal-content\">\n  <ng-template #template></ng-template>\n  <i class=\"fas fa-window-close\" (click)=\"onClose()\"></i>\n</div>\n```\nLe backdrop est également bindé à la méthode `onClose` car la modale doit également se fermer lorsque l'utilisateur clique dessus. \n\nCe composant va disposer d'un `@Input` pour récupérer le composant qu'il doit injecter, ainsi qu'un `@Output` afin d’émettre lors qu'il doit se fermer. \n\n```typescript\nexport class ModalComponent implements OnInit {\n\n  @Output()\n  close = new EventEmitter();\n\n  @Input()\n  component: { component: any; props: any };\n\n  onClose() {\n    this.close.emit();\n  }\n}\n```\n\nLe type de l'`@Input` component est `{ component: any; props: any }` ce qui permet de pouvoir également passer d’éventuelles `@Input` au composant à injecter.\n\nIl reste encore à gérer l'injection. Pour cela il faut utiliser un `@ViewChild` afin de récupérer une référence au **template** dans l'HTML du `ModalComponent` ainsi que du `ComponentFactoryResolver` afin récupérer la **factory** du composant à injecter. \n\n```typescript \nexport class ModalComponent implements OnInit {\n\n  @ViewChild('template', { read: ViewContainerRef })\n  container: ViewContainerRef;\n\n  constructor(private resolver: ComponentFactoryResolver) {}\n\n  ngOnInit() {\n    const factory = this.resolver.resolveComponentFactory(this.component.component);\n    const ref = this.container.createComponent(factory);\n    if (this.component.props) {\n      Object.assign(ref.instance, this.component.props);\n    }\n  }\n}\n```\n\nDans le `ngOnInit` du conteneur, on récupère la **factory** du composant à injecter, ensuite on utilise cette factory pour injecter ce composant dans le **template** et enfin, si des **props** ont été passées, on les assigne à notre composant.\n\nA ce stade, il est déjà possible d'utiliser le `ModalComponent` dans un template (bien que ce ne soit pas le but de ce composant)\n\n<iframe src=\"https://stackblitz.com/edit/modal-demo-oztzts?embed=1&file=src/app/app.component.html\" frameborder=\"0\" height=\"200px\" style=\"margin: 0 -24px; width: calc(100% + 48px)\" ></iframe>\n\n> <mat-icon aria-label=\"\" class=\"mat-icon material-icons\" role=\"img\" aria-hidden=\"true\">warning</mat-icon> Le `ModalComponent` n'étant pas présent dans un template de l'application, celui-ci doit être ajouté au tableau `entryComponents` du module principal de l'application \n\n## ModalService\n\nAfin de rendre possible l'ouvrir d'une modale depuis n'importe où dans l'application, il est nécessaire de créer un service. Celui-ci doit contenir une **méthode** permettant l'ouverture d'une modale et un `Observable` auquel l'`AppComponent` pourra **s'abonner** afin de gérer l'injection dans la page.\n\nPour gérer l'observable qu'expose ce service, il faut utiliser un [`Subject`](http://reactivex.io/documentation/subject.html) car il est possible d'émettre mais aussi de souscrire à cet objet.\n\nLa méthode d'ouverture de modale n'a alors plus qu'à émettre sur cet objet et le tour est joué.\n\n```typescript\n@Injectable({\n  providedIn: 'root'\n})\nexport class ModalService {\n  private componentSubject = new Subject<{ component: any; props: any }>();\n  component$ = this.componentSubject.asObservable();\n\n  constructor() { }\n\n  openInModal(component, props = null) {\n    this.componentSubject.next({ component, props });\n  }\n}\n```\n\n*On remarque ici que le `Subject` est exposé via sa méthode `asObservable()` qui permet d'éviter que l'on puisse émettre depuis l'extérieur du service.*\n>  <mat-icon aria-label=\"\" class=\"mat-icon material-icons\" role=\"img\" aria-hidden=\"true\">warning</mat-icon> Les componsants passés à la méthode `openInModal` n'étant pas présent dans un template de l'application, ceux-ci doivent être ajoutés au tableau `entryComponents` du module principal de l'application \n\n## AppComponent\n\nLa dernière étape consiste à gérer l'injection de la modale dans la page en se servant du `ModalService`.\n\nIl faut donc ici répéter ce qui a été fait dans le `ModalComponent` : Ajouter un template dans l'HTML de la page et injecter un composant de ce template. \n\nLes seules différences ici est qu'il ne faut pas le faire dans la méthode `ngOnInit` mais dans une souscription au `ModalService` (afin que la modale soit injectée à chaque fois que la méthode `openModal` est appelée). Il faut également gérer la fermeture de la modale.\n\n```html\n<ng-template #modalContainer></ng-template>\n```\n<br/>\n\n```typescript\nexport class AppComponent implements OnInit {\n  @ViewChild('modalContainer', { read: ViewContainerRef })\n  modalContainer: ViewContainerRef;\n\n  constructor(private modalService: ModalService, private resolver: ComponentFactoryResolver) {\n  }\n\n  ngOnInit() {\n    const factory = this.resolver.resolveComponentFactory(ModalComponent);\n\n    this.modalService.component$.subscribe(modal => {\n      this.modalContainer.clear();\n      const modalRef = this.modalContainer.createComponent(factory);\n      modalRef.instance.component = modal;\n\n      let sub: Subscription;\n      const cleanUp = () => { this.modalContainer.clear(); sub.unsubscribe(); };\n      sub = modalRef.instance.close.subscribe(cleanUp);\n      modalRef.onDestroy(cleanUp);\n    });\n  }\n}\n```\n\nOn peut voir ici que pour supprimer la modale du DOM, il suffit d'appeler la méthode `clear()` sur la référence de template.\n\nOn peut maintenant appeler depuis n'importe où dans notre application le `ModalService` afin d'ouvrir une modale\n\n```typescript\n openModal() {\n    this.modalService.openInModal(ExempleComponent, { name: 'Joe' });\n  }\n``` \n\nVoici un exemple complet dont le code source est [disponible sur github](https://github.com/Willovent/angular-modal-demo).\n\n<iframe src=\"https://stackblitz.com/edit/modal-demo?embed=1&file=src/app/app.component.ts\" frameborder=\"0\" height=\"500px\" style=\"margin: 0 -24px; width: calc(100% + 48px)\" ></iframe>\n\n**Happy coding !**"
    },
    {
      "Id": 32,
      "Url": "creer-une-cli-en-net",
      "Title": "Créer une CLI en .NET",
      "Description": "Dans cet article nous allons voir comment créer une CLI (Command Line Interface) en .NET Core.",
      "PublicationDate": "2018-09-20 00:00:00.000",
      "CategoryId": 1,
      "Tags": "cli,dotnet",
      "MarkDownContent": "Dans cet article nous allons voir comment créer une CLI (Command Line Interface) en .NET Core.\n\n## Pourquoi utiliser une CLI\n\nIl existe un grand nombre de scenario nécessitant l'utilisation de ce genre de petit utilitaire : \n- Automatiser une tâche répétitive\n- Simplifier un processus de développement autrement plus compliqué\n- Créer un outil d'aministration technique\n- etc...\n\n## Contexte\n\nDepuis .NET Core, les équipes de Microsoft ont eu à créer quelques CLI afin des outils pour rendre .NET plus utilisable dans un contexte open source (hors de Visual Studio). On pense ici principalement à la commande `dotnet` permettent créer, builder, packager etc... des applications en .NET Core.\n\nDans cette optique, Microsoft a donc créé des packages permettant de gérer ces CLI en interne, qu'ils ont ensuite poussé dans l'Open Source via le package Nuget [Microsoft.Extensions.Configuration.CommandLine](https://www.nuget.org/packages/Microsoft.Extensions.Configuration.CommandLine/). C'est ce package que nous allons utiliser ici.  \n\n## Le code\n\nPour créer une CLI, la première étape de générer un projet console .NET Core traditionnel. Cela peut se faire depuis Visual Studio ou avec la commande dotnet suivante : \n```cmd\ndotnet new console -n [name]\n```\nIl faut ensuite ajouter le paquet nuget  `Microsoft.Extensions.Configuration.CommandLine`. Encore une fois, on peut l'effectuer depuis l'interface de Visual Studio, ou avec la commande \n```cmd\ndotnet add package Microsoft.Extensions.Configuration.CommandLine\n```\n\nIl faut ensuite ajouter créer une instance de la classe `CommandLineApplication` et configurer notre CLI: \n```csharp\nstatic void Main(string[] args)\n{\n    var app = new CommandLineApplication();\n\n    app.HelpOption(\"-?|-h|--help\");\n    app.VersionOption(\"--version\", \"1.0.0\");\n\n    app.OnExecute(() =>\n    {\n        app.ShowHelp();\n        return 0;\n    });\n\n    try\n    {\n        app.Execute(args);\n    }\n    catch (CommandParsingException ex)\n    {\n        Console.WriteLine(ex.Message);\n        app.ShowHelp();\n    }\n}\n```\nDans cette configuration, on peut voir de quelle manière on configure une CLI. On a enregistrer ici la commande permettant d'afficher la version ainsi que celle permettant d'afficher l'aide. Dans le cas ou une erreur survient lors du parsing des arguments passé, on affiche l'aide.\n\nA ce stade, on peut déjà exécuté  la CLI. Son output sera le suivant : \n\n![cli](https://i.imgur.com/79Bpmjv.png)\n\nAjoutons une commande à notre CLI : \n\n```csharp\napp.Command(\"greetings\", command =>\n{\n\n    command.Description = \"Greet someone\";\n    command.HelpOption(\"-?|-h|--help\"); \n\n    var nameArg = command.Argument(\"[name]\", \"The name to greet\");\n    var fullOption = command.Option(\"-f|--full\", \"full greetings flag\", CommandOptionType.NoValue);\n\n    command.OnExecute(() =>\n    {\n        var name = nameArg.Value;\n        var fullGreetings = fullOption.HasValue();\n        Console.WriteLine($\"Hello {name}.\" + (fullGreetings? \" Hope you're fine !\" : \"\"));\n        return 0;\n    });\n});\n```\n\nOn a ici créé une commande `greeting`. Cette commande dispose d'un argument `name` et d'une option `full`. En compilant ces 2 inputs, la commande écrit un message dans la console. \n\nL'output de notre CLI est maintenant le suivant :\n\n![cli](https://i.imgur.com/BXgKyuk.png)\n\n**Happy Coding !**"
    },
    {
      "Id": 33,
      "Url": "ajouter-de-linjection-de-dependances-dans-un-cli-net",
      "Title": "Ajouter de l'injection de dépendances dans un CLI .NET",
      "Description": "Dans cet article nous allons voir comment utiliser l'injection de dépendances d'ASP.NET dans un project de CLI .NET.",
      "PublicationDate": "2018-11-14 00:00:00.000",
      "CategoryId": 1,
      "Tags": "dotnet,cli,asp.net",
      "MarkDownContent": "Dans cet article nous allons voir comment utiliser l'injection de dépendances d'ASP.NET dans un project de CLI .NET.\n Cet article va se baser sur la CLI créée dans l'article précédent [Créer une CLI en .NET](https://blog.williamklein.info/posts/ASP.NET/creer-une-cli-en-net), il est donc très fortement conseiller de le lire, ou de reprendre rapidement les exemples.\n\n## Pourquoi faire ?\n\nUtiliser le même système d'injection de dépendances que dans une API va permettre de mutualiser énormément de code. Pour prendre un exemple simple, on va pouvoir s'injecter avec la plus grande simplicité un contexte Entity Framework (ou autre ORM) dans une CLI en réutilisant toutes les configurations déjà utilisées dans une API.\n\n## Comment faire ?\n\nPour commencer, nous allons refactorer notre code et placer sa logique dans une classe qui hérite de `CommandLineApplication`. Pour cela, rien de plus simple, il nous suffit de passer toute la configuration dans le constructeur de la classe: \n\n```csharp\npublic class MaCLI: CommandLineApplication\n{\n    public MaCLI()\n    {\n        this.HelpOption(\"-?|-h|--help\");\n        this.VersionOption(\"--version\", \"1.0.0\");\n\n        this.Command(\"greetings\", command =>\n        {\n\n            command.Description = \"Greet someone\";\n            command.HelpOption(\"-?|-h|--help\");\n\n            var nameArg = command.Argument(\"[name]\", \"The name to greet\");\n            var fullOption = command.Option(\"-f|--full\", \"full greeting flag\", CommandOptionType.NoValue);\n\n            command.OnExecute(() =>\n            {\n                var name = nameArg.Value;\n                var fullGreeting = fullOption.HasValue();\n                Console.WriteLine($\"Hello {name}.\" + (fullGreeting ? \" Hope you're fine !\" : \"\"));\n                return 0;\n            });\n        });\n\n        this.OnExecute(() =>\n        {\n            this.ShowHelp();\n            return 0;\n        });\n    }\n}\n```\n\nPour utiliser cette CLI, il faut maintenant modifier la fonction `Main` du `Program.cs`. Il suffit maintenant d'instancier la classe précédemment créée et d'appeler la méthode `Execute` en lui passant les arguments : \n```csharp\nstatic void Main(string[] args)\n{\n    var app = new MaCLI();\n\n    try\n    {\n        app.Execute(args);\n    }\n    catch (CommandParsingException ex)\n    {\n        Console.WriteLine(ex.Message);\n        app.ShowHelp();\n    }\n}\n```\n\n\nPourquoi faire modifications ? Cela nous permet maintenant d'utiliser le moteurs d'injection de dépendances pour résoudre cette classe, et donc ses différentes dépendances que l'on peut ajouter dans son constructeur.\n\nPour cela, la première étape est d'ajouter le nuget `Microsoft.Extensions.DependencyInjection`. Comme toujours, on peut l'effectuer depuis l'interface de Visual Studio, ou avec la commande\n\n```cmd\ndotnet add package Microsoft.Extensions.DependencyInjection\n```\n\nUne fois ce package ajouté, on peut utiliser la classe `ServiceCollection` qui implémente l'interface `IServiceCollection` (La même interface qui est utilisée dans la méthode `ConfigureServices` dans le `StartUp` d'une application ASP.NET Core !). \nOn peut donc instancier cette classe et commencer à la remplir des différents services dont on va servir. Comme notre application n'a pas encore de dépendance, le code se résume alors à cela : \n```csharp\nvar services = new ServiceCollection();\nservices.AddScoped<MaCLI>();\n```\n\nEnsuite, pour récupérer une instance de notre classe `MaCLI` depuis le moteur de DI, il faut construire un `ServiceProvider` depuis notre collection de services. Cela se fait via la méthode `BuildServiceProvider` : \n```csharp\nvar serviceProvider = services.BuildServiceProvider();\n```\n\nC'est depuis ce service provider que l'on va pouvoir demander des instances de nos services. Pour cela il faut appeler la méthode `GetService` avec le type qui nous interèsse: \n```csharp\nvar app = serviceProvider.GetRequiredService<MaCLI>();\n```\n\nEt voilà !\n\nPour rendre l'utilité plus concrète, ajoutons un accès en base à notre CLI : \n\n```csharp\n public class MaCLI : CommandLineApplication\n{\n    public MaCLI(AppContext context)\n    {\n       ...\n\n        this.Command(\"greetings\", command =>\n        {\n            ...\n            CommandArgument idArg = command.Argument(\"[Id]\", \"Id of the user to greet\");            \n\n            command.OnExecute(() =>\n            {\n                if (int.TryParse(idArg.Value, out int id))\n                {\n                    User user = context.Users.First(x => x.Id == id);\n                    bool fullGreeting = fullOption.HasValue();\n                    Console.WriteLine($\"Hello {user.FirstName} {user.LastName}.\" + (fullGreeting ? \" Hope you're fine !\" : \"\"));\n                    return 0;\n                }\n                else\n                {\n                    Console.WriteLine($\"Argument 'Id' was not an integer\");\n                    return 1;\n                }\n            });\n        });\n        ...\n   }\n}\n```\n\nNotre CLI utilise maintenant un DbContext qui est injecté via son constructeur. Elle permet maintenant de saluer un user en base de données en fonction de son Id.\n\nIl nous faut maintenant configurer le `DbContext` dans notre `ServiceCollection`. Pour cela, rien de plus facile : \n\nComme il s'agit d'un `DbContext` qui est également utilisé dans mon Api, je dispose déjà du code permettant de configurer l'accès en base. Celui-ci se trouve dans une méthode d’extension qui prend en paramètre un `IServiceCollection` :\n```csharp\npublic static void ConfigureData(this IServiceCollection services)\n{\n    services.AddDbContext<AppContext>(...);\n}\n```\n\nJe n'ai donc plus qu'a appeler cette méthode dans mon `Main`. \n```csharp\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var services = new ServiceCollection();\n        ConfigureServices(services);\n        var serviceProvider = services.BuildServiceProvider();\n\n        var app = serviceProvider.GetRequiredService<MaCLI>();\n        try\n        {\n            app.Execute(args);\n        }\n        catch (CommandParsingException ex)\n        {\n            Console.WriteLine(ex.Message);\n            app.ShowHelp();\n        }\n    }\n    \n    static void ConfigureServices(IServiceCollection services)\n    {\n        services.ConfigureData();\n        services.AddScoped<MaCLI>();\n    }\n}\n``` \n\nOn peut également remarquer que la configuration des services se fait maintenant dans une méthode `ConfigureServices`. Ce n'est pas obligatoire, mais cela permet d'uniformiser le code avec ce qui se trouve coté API.\n\nLe code de cette petite CLI est disponible sur github [ici](https://github.com/Willovent/simple-dot-cli-with-di), n'hesitez pas à y jeter un oeil.\n\n**Happy Coding**"
    }
  ]